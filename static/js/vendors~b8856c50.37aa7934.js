(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{102:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return registerErrorInstrumentation; });\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n/* harmony import */ var _spanstatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);\n\n\n\n/**\n * Configures global error listeners\n */\nfunction registerErrorInstrumentation() {\n    Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_0__[/* addInstrumentationHandler */ "a"])({\n        callback: errorCallback,\n        type: \'error\',\n    });\n    Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_0__[/* addInstrumentationHandler */ "a"])({\n        callback: errorCallback,\n        type: \'unhandledrejection\',\n    });\n}\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback() {\n    var activeTransaction = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[/* getActiveTransaction */ "b"])();\n    if (activeTransaction) {\n        _sentry_utils__WEBPACK_IMPORTED_MODULE_1__[/* logger */ "a"].log("[Tracing] Transaction: " + _spanstatus__WEBPACK_IMPORTED_MODULE_2__[/* SpanStatus */ "a"].InternalError + " -> Global error occured");\n        activeTransaction.setStatus(_spanstatus__WEBPACK_IMPORTED_MODULE_2__[/* SpanStatus */ "a"].InternalError);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vZXJyb3JzLmpzP2Q5YjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgbG9nZ2VyIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgeyBTcGFuU3RhdHVzIH0gZnJvbSAnLi9zcGFuc3RhdHVzJztcbmltcG9ydCB7IGdldEFjdGl2ZVRyYW5zYWN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG4vKipcbiAqIENvbmZpZ3VyZXMgZ2xvYmFsIGVycm9yIGxpc3RlbmVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckluc3RydW1lbnRhdGlvbigpIHtcbiAgICBhZGRJbnN0cnVtZW50YXRpb25IYW5kbGVyKHtcbiAgICAgICAgY2FsbGJhY2s6IGVycm9yQ2FsbGJhY2ssXG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgfSk7XG4gICAgYWRkSW5zdHJ1bWVudGF0aW9uSGFuZGxlcih7XG4gICAgICAgIGNhbGxiYWNrOiBlcnJvckNhbGxiYWNrLFxuICAgICAgICB0eXBlOiAndW5oYW5kbGVkcmVqZWN0aW9uJyxcbiAgICB9KTtcbn1cbi8qKlxuICogSWYgYW4gZXJyb3Igb3IgdW5oYW5kbGVkIHByb21pc2Ugb2NjdXJzLCB3ZSBtYXJrIHRoZSBhY3RpdmUgdHJhbnNhY3Rpb24gYXMgZmFpbGVkXG4gKi9cbmZ1bmN0aW9uIGVycm9yQ2FsbGJhY2soKSB7XG4gICAgdmFyIGFjdGl2ZVRyYW5zYWN0aW9uID0gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIltUcmFjaW5nXSBUcmFuc2FjdGlvbjogXCIgKyBTcGFuU3RhdHVzLkludGVybmFsRXJyb3IgKyBcIiAtPiBHbG9iYWwgZXJyb3Igb2NjdXJlZFwiKTtcbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24uc2V0U3RhdHVzKFNwYW5TdGF0dXMuSW50ZXJuYWxFcnJvcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///102\n')},142:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return init; });\n/* harmony import */ var _sentry_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);\n/* harmony import */ var _sentry_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(130);\n\n/**\n * Inits the React SDK\n */\nfunction init(options) {\n    options._metadata = options._metadata || {};\n    if (options._metadata.sdk === undefined) {\n        options._metadata.sdk = {\n            name: \'sentry.javascript.react\',\n            packages: [\n                {\n                    name: \'npm:@sentry/react\',\n                    version: _sentry_browser__WEBPACK_IMPORTED_MODULE_0__[/* SDK_VERSION */ "a"],\n                },\n            ],\n            version: _sentry_browser__WEBPACK_IMPORTED_MODULE_0__[/* SDK_VERSION */ "a"],\n        };\n    }\n    Object(_sentry_browser__WEBPACK_IMPORTED_MODULE_1__[/* init */ "a"])(options);\n}\n//# sourceMappingURL=sdk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvcmVhY3QvZXNtL3Nkay5qcz8yZjBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXQgYXMgYnJvd3NlckluaXQsIFNES19WRVJTSU9OIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbi8qKlxuICogSW5pdHMgdGhlIFJlYWN0IFNES1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5fbWV0YWRhdGEgPSBvcHRpb25zLl9tZXRhZGF0YSB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5fbWV0YWRhdGEuc2RrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5fbWV0YWRhdGEuc2RrID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlbnRyeS5qYXZhc2NyaXB0LnJlYWN0JyxcbiAgICAgICAgICAgIHBhY2thZ2VzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbnBtOkBzZW50cnkvcmVhY3QnLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBTREtfVkVSU0lPTixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHZlcnNpb246IFNES19WRVJTSU9OLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBicm93c2VySW5pdChvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNkay5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///142\n')},146:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ browsertracing_BrowserTracing; });\n\n// UNUSED EXPORTS: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, getHeaderContext, getMetaContent\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/logger.js\nvar logger = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/misc.js\nvar misc = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/hubextensions.js\nvar hubextensions = __webpack_require__(47);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/idletransaction.js\nvar idletransaction = __webpack_require__(54);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/spanstatus.js\nvar spanstatus = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/utils.js\nvar utils = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/backgroundtab.js\n\n\n\nvar global = Object(misc[\"e\" /* getGlobalObject */])();\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nfunction registerBackgroundTabDetection() {\n    if (global && global.document) {\n        global.document.addEventListener('visibilitychange', function () {\n            var activeTransaction = Object(utils[\"b\" /* getActiveTransaction */])();\n            if (global.document.hidden && activeTransaction) {\n                logger[\"a\" /* logger */].log(\"[Tracing] Transaction: \" + spanstatus[\"a\" /* SpanStatus */].Cancelled + \" -> since tab moved to the background, op: \" + activeTransaction.op);\n                // We should not set status if it is already set, this prevent important statuses like\n                // error or data loss from being overwritten on transaction.\n                if (!activeTransaction.status) {\n                    activeTransaction.setStatus(spanstatus[\"a\" /* SpanStatus */].Cancelled);\n                }\n                activeTransaction.setTag('visibilitychange', 'document.hidden');\n                activeTransaction.finish();\n            }\n        });\n    }\n    else {\n        logger[\"a\" /* logger */].warn('[Tracing] Could not set up background tab detection due to lack of global document');\n    }\n}\n//# sourceMappingURL=backgroundtab.js.map\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/time.js\nvar time = __webpack_require__(59);\n\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar bindReporter = function (callback, metric, po, observeAllUpdates) {\n    var prevValue;\n    return function () {\n        if (po && metric.isFinal) {\n            po.disconnect();\n        }\n        if (metric.value >= 0) {\n            if (observeAllUpdates || metric.isFinal || document.visibilityState === 'hidden') {\n                metric.delta = metric.value - (prevValue || 0);\n                // Report the metric if there's a non-zero delta, if the metric is\n                // final, or if no previous value exists (which can happen in the case\n                // of the document becoming hidden when the metric value is 0).\n                // See: https://github.com/GoogleChrome/web-vitals/issues/14\n                if (metric.delta || metric.isFinal || prevValue === undefined) {\n                    callback(metric);\n                    prevValue = metric.value;\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=bindReporter.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Performantly generate a unique, 27-char string by combining the current\n * timestamp with a 13-digit random number.\n * @return {string}\n */\nvar generateUniqueID = function () {\n    return Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n};\n//# sourceMappingURL=generateUniqueID.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar initMetric = function (name, value) {\n    if (value === void 0) { value = -1; }\n    return {\n        name: name,\n        value: value,\n        delta: 0,\n        entries: [],\n        id: generateUniqueID(),\n        isFinal: false,\n    };\n};\n//# sourceMappingURL=initMetric.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nvar observe = function (type, callback) {\n    try {\n        if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n            var po = new PerformanceObserver(function (l) { return l.getEntries().map(callback); });\n            po.observe({ type: type, buffered: true });\n            return po;\n        }\n    }\n    catch (e) {\n        // Do nothing.\n    }\n    return;\n};\n//# sourceMappingURL=observe.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar isUnloading = false;\nvar listenersAdded = false;\nvar onPageHide = function (event) {\n    isUnloading = !event.persisted;\n};\nvar addListeners = function () {\n    addEventListener('pagehide', onPageHide);\n    // `beforeunload` is needed to fix this bug:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=987409\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    addEventListener('beforeunload', function () { });\n};\nvar onHidden = function (cb, once) {\n    if (once === void 0) { once = false; }\n    if (!listenersAdded) {\n        addListeners();\n        listenersAdded = true;\n    }\n    addEventListener('visibilitychange', function (_a) {\n        var timeStamp = _a.timeStamp;\n        if (document.visibilityState === 'hidden') {\n            cb({ timeStamp: timeStamp, isUnloading: isUnloading });\n        }\n    }, { capture: true, once: once });\n};\n//# sourceMappingURL=onHidden.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar getCLS = function (onReport, reportAllChanges) {\n    if (reportAllChanges === void 0) { reportAllChanges = false; }\n    var metric = initMetric('CLS', 0);\n    var report;\n    var entryHandler = function (entry) {\n        // Only count layout shifts without recent user input.\n        if (!entry.hadRecentInput) {\n            metric.value += entry.value;\n            metric.entries.push(entry);\n            report();\n        }\n    };\n    var po = observe('layout-shift', entryHandler);\n    if (po) {\n        report = bindReporter(onReport, metric, po, reportAllChanges);\n        onHidden(function (_a) {\n            var isUnloading = _a.isUnloading;\n            po.takeRecords().map(entryHandler);\n            if (isUnloading) {\n                metric.isFinal = true;\n            }\n            report();\n        });\n    }\n};\n//# sourceMappingURL=getCLS.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getFirstHidden.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar firstHiddenTime;\nvar getFirstHidden = function () {\n    if (firstHiddenTime === undefined) {\n        // If the document is hidden when this code runs, assume it was hidden\n        // since navigation start. This isn't a perfect heuristic, but it's the\n        // best we can do until an API is available to support querying past\n        // visibilityState.\n        firstHiddenTime = document.visibilityState === 'hidden' ? 0 : Infinity;\n        // Update the time if/when the document becomes hidden.\n        onHidden(function (_a) {\n            var timeStamp = _a.timeStamp;\n            return (firstHiddenTime = timeStamp);\n        }, true);\n    }\n    return {\n        get timeStamp() {\n            return firstHiddenTime;\n        },\n    };\n};\n//# sourceMappingURL=getFirstHidden.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar getFID = function (onReport) {\n    var metric = initMetric('FID');\n    var firstHidden = getFirstHidden();\n    var entryHandler = function (entry) {\n        // Only report if the page wasn't hidden prior to the first input.\n        if (entry.startTime < firstHidden.timeStamp) {\n            metric.value = entry.processingStart - entry.startTime;\n            metric.entries.push(entry);\n            metric.isFinal = true;\n            report();\n        }\n    };\n    var po = observe('first-input', entryHandler);\n    var report = bindReporter(onReport, metric, po);\n    if (po) {\n        onHidden(function () {\n            po.takeRecords().map(entryHandler);\n            po.disconnect();\n        }, true);\n    }\n    else {\n        if (window.perfMetrics && window.perfMetrics.onFirstInputDelay) {\n            window.perfMetrics.onFirstInputDelay(function (value, event) {\n                // Only report if the page wasn't hidden prior to the first input.\n                if (event.timeStamp < firstHidden.timeStamp) {\n                    metric.value = value;\n                    metric.isFinal = true;\n                    metric.entries = [\n                        {\n                            entryType: 'first-input',\n                            name: event.type,\n                            target: event.target,\n                            cancelable: event.cancelable,\n                            startTime: event.timeStamp,\n                            processingStart: event.timeStamp + value,\n                        },\n                    ];\n                    report();\n                }\n            });\n        }\n    }\n};\n//# sourceMappingURL=getFID.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/whenInput.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar inputPromise;\nvar whenInput = function () {\n    if (!inputPromise) {\n        inputPromise = new Promise(function (r) {\n            return ['scroll', 'keydown', 'pointerdown'].map(function (type) {\n                addEventListener(type, r, {\n                    once: true,\n                    passive: true,\n                    capture: true,\n                });\n            });\n        });\n    }\n    return inputPromise;\n};\n//# sourceMappingURL=whenInput.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\nvar getLCP = function (onReport, reportAllChanges) {\n    if (reportAllChanges === void 0) { reportAllChanges = false; }\n    var metric = initMetric('LCP');\n    var firstHidden = getFirstHidden();\n    var report;\n    var entryHandler = function (entry) {\n        // The startTime attribute returns the value of the renderTime if it is not 0,\n        // and the value of the loadTime otherwise.\n        var value = entry.startTime;\n        // If the page was hidden prior to paint time of the entry,\n        // ignore it and mark the metric as final, otherwise add the entry.\n        if (value < firstHidden.timeStamp) {\n            metric.value = value;\n            metric.entries.push(entry);\n        }\n        else {\n            metric.isFinal = true;\n        }\n        report();\n    };\n    var po = observe('largest-contentful-paint', entryHandler);\n    if (po) {\n        report = bindReporter(onReport, metric, po, reportAllChanges);\n        var onFinal = function () {\n            if (!metric.isFinal) {\n                po.takeRecords().map(entryHandler);\n                metric.isFinal = true;\n                report();\n            }\n        };\n        void whenInput().then(onFinal);\n        onHidden(onFinal, true);\n    }\n};\n//# sourceMappingURL=getLCP.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/web-vitals/getTTFB.js\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar getTTFB_global = Object(misc[\"e\" /* getGlobalObject */])();\nvar afterLoad = function (callback) {\n    if (document.readyState === 'complete') {\n        // Queue a task so the callback runs after `loadEventEnd`.\n        setTimeout(callback, 0);\n    }\n    else {\n        // Use `pageshow` so the callback runs after `loadEventEnd`.\n        addEventListener('pageshow', callback);\n    }\n};\nvar getNavigationEntryFromPerformanceTiming = function () {\n    // Really annoying that TypeScript errors when using `PerformanceTiming`.\n    // eslint-disable-next-line deprecation/deprecation\n    var timing = getTTFB_global.performance.timing;\n    var navigationEntry = {\n        entryType: 'navigation',\n        startTime: 0,\n    };\n    for (var key in timing) {\n        if (key !== 'navigationStart' && key !== 'toJSON') {\n            navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);\n        }\n    }\n    return navigationEntry;\n};\nvar getTTFB = function (onReport) {\n    var metric = initMetric('TTFB');\n    afterLoad(function () {\n        try {\n            // Use the NavigationTiming L2 entry if available.\n            var navigationEntry = getTTFB_global.performance.getEntriesByType('navigation')[0] || getNavigationEntryFromPerformanceTiming();\n            metric.value = metric.delta = navigationEntry.responseStart;\n            metric.entries = [navigationEntry];\n            onReport(metric);\n        }\n        catch (error) {\n            // Do nothing.\n        }\n    });\n};\n//# sourceMappingURL=getTTFB.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/metrics.js\n\n\n\n\n\n\n\n\nvar metrics_global = Object(misc[\"e\" /* getGlobalObject */])();\n/** Class tracking metrics  */\nvar metrics_MetricsInstrumentation = /** @class */ (function () {\n    function MetricsInstrumentation() {\n        this._measurements = {};\n        this._performanceCursor = 0;\n        if (metrics_global && metrics_global.performance) {\n            if (metrics_global.performance.mark) {\n                metrics_global.performance.mark('sentry-tracing-init');\n            }\n            this._trackCLS();\n            this._trackLCP();\n            this._trackFID();\n            this._trackTTFB();\n        }\n    }\n    /** Add performance related spans to a transaction */\n    MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n        var _this = this;\n        if (!metrics_global || !metrics_global.performance || !metrics_global.performance.getEntries || !time[\"a\" /* browserPerformanceTimeOrigin */]) {\n            // Gatekeeper if performance API not available\n            return;\n        }\n        logger[\"a\" /* logger */].log('[Tracing] Adding & adjusting spans using Performance API');\n        var timeOrigin = Object(utils[\"d\" /* msToSec */])(time[\"a\" /* browserPerformanceTimeOrigin */]);\n        var entryScriptSrc;\n        if (metrics_global.document) {\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (var i = 0; i < document.scripts.length; i++) {\n                // We go through all scripts on the page and look for 'data-entry'\n                // We remember the name and measure the time between this script finished loading and\n                // our mark 'sentry-tracing-init'\n                if (document.scripts[i].dataset.entry === 'true') {\n                    entryScriptSrc = document.scripts[i].src;\n                    break;\n                }\n            }\n        }\n        var entryScriptStartTimestamp;\n        var tracingInitMarkStartTime;\n        metrics_global.performance\n            .getEntries()\n            .slice(this._performanceCursor)\n            .forEach(function (entry) {\n            var startTime = Object(utils[\"d\" /* msToSec */])(entry.startTime);\n            var duration = Object(utils[\"d\" /* msToSec */])(entry.duration);\n            if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n                return;\n            }\n            switch (entry.entryType) {\n                case 'navigation':\n                    addNavigationSpans(transaction, entry, timeOrigin);\n                    break;\n                case 'mark':\n                case 'paint':\n                case 'measure': {\n                    var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n                    if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n                        tracingInitMarkStartTime = startTimestamp;\n                    }\n                    // capture web vitals\n                    var firstHidden = getFirstHidden();\n                    // Only report if the page wasn't hidden prior to the web vital.\n                    var shouldRecord = entry.startTime < firstHidden.timeStamp;\n                    if (entry.name === 'first-paint' && shouldRecord) {\n                        logger[\"a\" /* logger */].log('[Measurements] Adding FP');\n                        _this._measurements['fp'] = { value: entry.startTime };\n                        _this._measurements['mark.fp'] = { value: startTimestamp };\n                    }\n                    if (entry.name === 'first-contentful-paint' && shouldRecord) {\n                        logger[\"a\" /* logger */].log('[Measurements] Adding FCP');\n                        _this._measurements['fcp'] = { value: entry.startTime };\n                        _this._measurements['mark.fcp'] = { value: startTimestamp };\n                    }\n                    break;\n                }\n                case 'resource': {\n                    var resourceName = entry.name.replace(window.location.origin, '');\n                    var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n                    // We remember the entry script end time to calculate the difference to the first init mark\n                    if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n                        entryScriptStartTimestamp = endTimestamp;\n                    }\n                    break;\n                }\n                default:\n                // Ignore other entry types.\n            }\n        });\n        if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n            _startChild(transaction, {\n                description: 'evaluation',\n                endTimestamp: tracingInitMarkStartTime,\n                op: 'script',\n                startTimestamp: entryScriptStartTimestamp,\n            });\n        }\n        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n        this._trackNavigator(transaction);\n        // Measurements are only available for pageload transactions\n        if (transaction.op === 'pageload') {\n            // normalize applicable web vital values to be relative to transaction.startTimestamp\n            var timeOrigin_1 = Object(utils[\"d\" /* msToSec */])(time[\"a\" /* browserPerformanceTimeOrigin */]);\n            ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {\n                if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {\n                    return;\n                }\n                // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n                // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n                // to be adjusted to be relative to transaction.startTimestamp.\n                var oldValue = _this._measurements[name].value;\n                var measurementTimestamp = timeOrigin_1 + Object(utils[\"d\" /* msToSec */])(oldValue);\n                // normalizedValue should be in milliseconds\n                var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n                var delta = normalizedValue - oldValue;\n                logger[\"a\" /* logger */].log(\"[Measurements] Normalized \" + name + \" from \" + oldValue + \" to \" + normalizedValue + \" (\" + delta + \")\");\n                _this._measurements[name].value = normalizedValue;\n            });\n            if (this._measurements['mark.fid'] && this._measurements['fid']) {\n                // create span for FID\n                _startChild(transaction, {\n                    description: 'first input delay',\n                    endTimestamp: this._measurements['mark.fid'].value + Object(utils[\"d\" /* msToSec */])(this._measurements['fid'].value),\n                    op: 'web.vitals',\n                    startTimestamp: this._measurements['mark.fid'].value,\n                });\n            }\n            transaction.setMeasurements(this._measurements);\n        }\n    };\n    /** Starts tracking the Cumulative Layout Shift on the current page. */\n    MetricsInstrumentation.prototype._trackCLS = function () {\n        var _this = this;\n        getCLS(function (metric) {\n            var entry = metric.entries.pop();\n            if (!entry) {\n                return;\n            }\n            logger[\"a\" /* logger */].log('[Measurements] Adding CLS');\n            _this._measurements['cls'] = { value: metric.value };\n        });\n    };\n    /**\n     * Capture the information of the user agent.\n     */\n    MetricsInstrumentation.prototype._trackNavigator = function (transaction) {\n        var navigator = metrics_global.navigator;\n        if (!navigator) {\n            return;\n        }\n        // track network connectivity\n        var connection = navigator.connection;\n        if (connection) {\n            if (connection.effectiveType) {\n                transaction.setTag('effectiveConnectionType', connection.effectiveType);\n            }\n            if (connection.type) {\n                transaction.setTag('connectionType', connection.type);\n            }\n            if (isMeasurementValue(connection.rtt)) {\n                this._measurements['connection.rtt'] = { value: connection.rtt };\n            }\n            if (isMeasurementValue(connection.downlink)) {\n                this._measurements['connection.downlink'] = { value: connection.downlink };\n            }\n        }\n        if (isMeasurementValue(navigator.deviceMemory)) {\n            transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n        }\n        if (isMeasurementValue(navigator.hardwareConcurrency)) {\n            transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n        }\n    };\n    /** Starts tracking the Largest Contentful Paint on the current page. */\n    MetricsInstrumentation.prototype._trackLCP = function () {\n        var _this = this;\n        getLCP(function (metric) {\n            var entry = metric.entries.pop();\n            if (!entry) {\n                return;\n            }\n            var timeOrigin = Object(utils[\"d\" /* msToSec */])(performance.timeOrigin);\n            var startTime = Object(utils[\"d\" /* msToSec */])(entry.startTime);\n            logger[\"a\" /* logger */].log('[Measurements] Adding LCP');\n            _this._measurements['lcp'] = { value: metric.value };\n            _this._measurements['mark.lcp'] = { value: timeOrigin + startTime };\n        });\n    };\n    /** Starts tracking the First Input Delay on the current page. */\n    MetricsInstrumentation.prototype._trackFID = function () {\n        var _this = this;\n        getFID(function (metric) {\n            var entry = metric.entries.pop();\n            if (!entry) {\n                return;\n            }\n            var timeOrigin = Object(utils[\"d\" /* msToSec */])(performance.timeOrigin);\n            var startTime = Object(utils[\"d\" /* msToSec */])(entry.startTime);\n            logger[\"a\" /* logger */].log('[Measurements] Adding FID');\n            _this._measurements['fid'] = { value: metric.value };\n            _this._measurements['mark.fid'] = { value: timeOrigin + startTime };\n        });\n    };\n    /** Starts tracking the Time to First Byte on the current page. */\n    MetricsInstrumentation.prototype._trackTTFB = function () {\n        var _this = this;\n        getTTFB(function (metric) {\n            var _a;\n            var entry = metric.entries.pop();\n            if (!entry) {\n                return;\n            }\n            logger[\"a\" /* logger */].log('[Measurements] Adding TTFB');\n            _this._measurements['ttfb'] = { value: metric.value };\n            // Capture the time spent making the request and receiving the first byte of the response\n            var requestTime = metric.value - (_a = metric.entries[0], (_a !== null && _a !== void 0 ? _a : entry)).requestStart;\n            _this._measurements['ttfb.requestTime'] = { value: requestTime };\n        });\n    };\n    return MetricsInstrumentation;\n}());\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n    addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n    addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);\n    addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n    addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n    addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n    addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');\n    addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');\n    addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n    addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n    var measureStartTimestamp = timeOrigin + startTime;\n    var measureEndTimestamp = measureStartTimestamp + duration;\n    _startChild(transaction, {\n        description: entry.name,\n        endTimestamp: measureEndTimestamp,\n        op: entry.entryType,\n        startTimestamp: measureStartTimestamp,\n    });\n    return measureStartTimestamp;\n}\n/** Create resource-related spans */\nfunction addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n    // we already instrument based on fetch and xhr, so we don't need to\n    // duplicate spans here.\n    if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n        return undefined;\n    }\n    var data = {};\n    if ('transferSize' in entry) {\n        data['Transfer Size'] = entry.transferSize;\n    }\n    if ('encodedBodySize' in entry) {\n        data['Encoded Body Size'] = entry.encodedBodySize;\n    }\n    if ('decodedBodySize' in entry) {\n        data['Decoded Body Size'] = entry.decodedBodySize;\n    }\n    var startTimestamp = timeOrigin + startTime;\n    var endTimestamp = startTimestamp + duration;\n    _startChild(transaction, {\n        description: resourceName,\n        endTimestamp: endTimestamp,\n        op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n        startTimestamp: startTimestamp,\n        data: data,\n    });\n    return endTimestamp;\n}\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {\n    var end = eventEnd ? entry[eventEnd] : entry[event + \"End\"];\n    var start = entry[event + \"Start\"];\n    if (!start || !end) {\n        return;\n    }\n    _startChild(transaction, {\n        op: 'browser',\n        description: event,\n        startTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(start),\n        endTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(end),\n    });\n}\n/** Create request and response related spans */\nfunction addRequest(transaction, entry, timeOrigin) {\n    _startChild(transaction, {\n        op: 'browser',\n        description: 'request',\n        startTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(entry.requestStart),\n        endTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(entry.responseEnd),\n    });\n    _startChild(transaction, {\n        op: 'browser',\n        description: 'response',\n        startTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(entry.responseStart),\n        endTimestamp: timeOrigin + Object(utils[\"d\" /* msToSec */])(entry.responseEnd),\n    });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction _startChild(transaction, _a) {\n    var startTimestamp = _a.startTimestamp, ctx = Object(tslib_es6[\"f\" /* __rest */])(_a, [\"startTimestamp\"]);\n    if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n        transaction.startTimestamp = startTimestamp;\n    }\n    return transaction.startChild(Object(tslib_es6[\"a\" /* __assign */])({ startTimestamp: startTimestamp }, ctx));\n}\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n    return typeof value === 'number' && isFinite(value);\n}\n//# sourceMappingURL=metrics.js.map\n// EXTERNAL MODULE: ./node_modules/@sentry/tracing/esm/browser/request.js\nvar request = __webpack_require__(64);\n\n// EXTERNAL MODULE: ./node_modules/@sentry/utils/esm/instrument.js\nvar instrument = __webpack_require__(35);\n\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/router.js\n\nvar router_global = Object(misc[\"e\" /* getGlobalObject */])();\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {\n    if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }\n    if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }\n    if (!router_global || !router_global.location) {\n        logger[\"a\" /* logger */].warn('Could not initialize routing instrumentation due to invalid location');\n        return;\n    }\n    var startingUrl = router_global.location.href;\n    var activeTransaction;\n    if (startTransactionOnPageLoad) {\n        activeTransaction = customStartTransaction({ name: router_global.location.pathname, op: 'pageload' });\n    }\n    if (startTransactionOnLocationChange) {\n        Object(instrument[\"a\" /* addInstrumentationHandler */])({\n            callback: function (_a) {\n                var to = _a.to, from = _a.from;\n                /**\n                 * This early return is there to account for some cases where a navigation transaction starts right after\n                 * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n                 * create an uneccessary navigation transaction.\n                 *\n                 * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n                 * only be caused in certain development environments where the usage of a hot module reloader is causing\n                 * errors.\n                 */\n                if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n                    startingUrl = undefined;\n                    return;\n                }\n                if (from !== to) {\n                    startingUrl = undefined;\n                    if (activeTransaction) {\n                        logger[\"a\" /* logger */].log(\"[Tracing] Finishing current transaction with op: \" + activeTransaction.op);\n                        // If there's an open transaction on the scope, we need to finish it before creating an new one.\n                        activeTransaction.finish();\n                    }\n                    activeTransaction = customStartTransaction({ name: router_global.location.pathname, op: 'navigation' });\n                }\n            },\n            type: 'history',\n        });\n    }\n}\n//# sourceMappingURL=router.js.map\n// CONCATENATED MODULE: ./node_modules/@sentry/tracing/esm/browser/browsertracing.js\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;\nvar DEFAULT_BROWSER_TRACING_OPTIONS = Object(tslib_es6[\"a\" /* __assign */])({ idleTimeout: idletransaction[\"a\" /* DEFAULT_IDLE_TIMEOUT */], markBackgroundTransactions: true, maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, request[\"a\" /* defaultRequestInstrumentationOptions */]);\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nvar browsertracing_BrowserTracing = /** @class */ (function () {\n    function BrowserTracing(_options) {\n        /**\n         * @inheritDoc\n         */\n        this.name = BrowserTracing.id;\n        this._metrics = new metrics_MetricsInstrumentation();\n        this._emitOptionsWarning = false;\n        var tracingOrigins = request[\"a\" /* defaultRequestInstrumentationOptions */].tracingOrigins;\n        // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances\n        if (_options &&\n            _options.tracingOrigins &&\n            Array.isArray(_options.tracingOrigins) &&\n            _options.tracingOrigins.length !== 0) {\n            tracingOrigins = _options.tracingOrigins;\n        }\n        else {\n            this._emitOptionsWarning = true;\n        }\n        this.options = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins: tracingOrigins });\n    }\n    /**\n     * @inheritDoc\n     */\n    BrowserTracing.prototype.setupOnce = function (_, getCurrentHub) {\n        var _this = this;\n        this._getCurrentHub = getCurrentHub;\n        if (this._emitOptionsWarning) {\n            logger[\"a\" /* logger */].warn('[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.');\n            logger[\"a\" /* logger */].warn(\"[Tracing] We added a reasonable default for you: \" + request[\"a\" /* defaultRequestInstrumentationOptions */].tracingOrigins);\n        }\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;\n        instrumentRouting(function (context) { return _this._createRouteTransaction(context); }, startTransactionOnPageLoad, startTransactionOnLocationChange);\n        if (markBackgroundTransactions) {\n            registerBackgroundTabDetection();\n        }\n        Object(request[\"b\" /* instrumentOutgoingRequests */])({ traceFetch: traceFetch, traceXHR: traceXHR, tracingOrigins: tracingOrigins, shouldCreateSpanForRequest: shouldCreateSpanForRequest });\n    };\n    /** Create routing idle transaction. */\n    BrowserTracing.prototype._createRouteTransaction = function (context) {\n        var _this = this;\n        if (!this._getCurrentHub) {\n            logger[\"a\" /* logger */].warn(\"[Tracing] Did not create \" + context.op + \" transaction because _getCurrentHub is invalid.\");\n            return undefined;\n        }\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;\n        var parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;\n        var expandedContext = Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, context), parentContextFromHeader), { trimEnd: true });\n        var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n        // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n        // from being sent to Sentry).\n        var finalContext = modifiedContext === undefined ? Object(tslib_es6[\"a\" /* __assign */])(Object(tslib_es6[\"a\" /* __assign */])({}, expandedContext), { sampled: false }) : modifiedContext;\n        if (finalContext.sampled === false) {\n            logger[\"a\" /* logger */].log(\"[Tracing] Will not send \" + finalContext.op + \" transaction because of beforeNavigate.\");\n        }\n        logger[\"a\" /* logger */].log(\"[Tracing] Starting \" + finalContext.op + \" transaction on scope\");\n        var hub = this._getCurrentHub();\n        var location = Object(misc[\"e\" /* getGlobalObject */])().location;\n        var idleTransaction = Object(hubextensions[\"b\" /* startIdleTransaction */])(hub, finalContext, idleTimeout, true, { location: location });\n        idleTransaction.registerBeforeFinishCallback(function (transaction, endTimestamp) {\n            _this._metrics.addPerformanceEntries(transaction);\n            adjustTransactionDuration(Object(utils[\"e\" /* secToMs */])(maxTransactionDuration), transaction, endTimestamp);\n        });\n        return idleTransaction;\n    };\n    /**\n     * @inheritDoc\n     */\n    BrowserTracing.id = 'BrowserTracing';\n    return BrowserTracing;\n}());\n\n/**\n * Gets transaction context from a sentry-trace meta.\n *\n * @returns Transaction context data from the header or undefined if there's no header or the header is malformed\n */\nfunction getHeaderContext() {\n    var header = getMetaContent('sentry-trace');\n    if (header) {\n        return Object(utils[\"a\" /* extractTraceparentData */])(header);\n    }\n    return undefined;\n}\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n    var el = document.querySelector(\"meta[name=\" + metaName + \"]\");\n    return el ? el.getAttribute('content') : null;\n}\n/** Adjusts transaction value based on max transaction duration */\nfunction adjustTransactionDuration(maxDuration, transaction, endTimestamp) {\n    var diff = endTimestamp - transaction.startTimestamp;\n    var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);\n    if (isOutdatedTransaction) {\n        transaction.setStatus(spanstatus[\"a\" /* SpanStatus */].DeadlineExceeded);\n        transaction.setTag('maxTransactionDurationExceeded', 'true');\n    }\n}\n//# sourceMappingURL=browsertracing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vYnJvd3Nlci9iYWNrZ3JvdW5kdGFiLmpzPzA4OWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vYnJvd3Nlci93ZWItdml0YWxzL2xpYi9iaW5kUmVwb3J0ZXIuanM/MTY2ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvbGliL2dlbmVyYXRlVW5pcXVlSUQuanM/N2M5MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvbGliL2luaXRNZXRyaWMuanM/NmUzYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvbGliL29ic2VydmUuanM/MzFhMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvbGliL29uSGlkZGVuLmpzP2VhNjMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vYnJvd3Nlci93ZWItdml0YWxzL2dldENMUy5qcz80OTZiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L3RyYWNpbmcvZXNtL2Jyb3dzZXIvd2ViLXZpdGFscy9saWIvZ2V0Rmlyc3RIaWRkZW4uanM/ZTQ4YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvZ2V0RklELmpzPzkxZWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vYnJvd3Nlci93ZWItdml0YWxzL2xpYi93aGVuSW5wdXQuanM/Mjc3YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3dlYi12aXRhbHMvZ2V0TENQLmpzPzAwYTQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnkvdHJhY2luZy9lc20vYnJvd3Nlci93ZWItdml0YWxzL2dldFRURkIuanM/N2JlMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL21ldHJpY3MuanM/YjY3ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3JvdXRlci5qcz9jNjkwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5L3RyYWNpbmcvZXNtL2Jyb3dzZXIvYnJvd3NlcnRyYWNpbmcuanM/Y2M3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRHbG9iYWxPYmplY3QsIGxvZ2dlciB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgU3BhblN0YXR1cyB9IGZyb20gJy4uL3NwYW5zdGF0dXMnO1xuaW1wb3J0IHsgZ2V0QWN0aXZlVHJhbnNhY3Rpb24gfSBmcm9tICcuLi91dGlscyc7XG52YXIgZ2xvYmFsID0gZ2V0R2xvYmFsT2JqZWN0KCk7XG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIHRoYXQgY2FuY2VscyBhbmQgZmluaXNoZXMgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZSBnbG9iYWxcbiAqIGRvY3VtZW50IGlzIGhpZGRlbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQmFja2dyb3VuZFRhYkRldGVjdGlvbigpIHtcbiAgICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgICBnbG9iYWwuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsLmRvY3VtZW50LmhpZGRlbiAmJiBhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbVHJhY2luZ10gVHJhbnNhY3Rpb246IFwiICsgU3BhblN0YXR1cy5DYW5jZWxsZWQgKyBcIiAtPiBzaW5jZSB0YWIgbW92ZWQgdG8gdGhlIGJhY2tncm91bmQsIG9wOiBcIiArIGFjdGl2ZVRyYW5zYWN0aW9uLm9wKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IHNldCBzdGF0dXMgaWYgaXQgaXMgYWxyZWFkeSBzZXQsIHRoaXMgcHJldmVudCBpbXBvcnRhbnQgc3RhdHVzZXMgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGVycm9yIG9yIGRhdGEgbG9zcyBmcm9tIGJlaW5nIG92ZXJ3cml0dGVuIG9uIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmICghYWN0aXZlVHJhbnNhY3Rpb24uc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uLnNldFN0YXR1cyhTcGFuU3RhdHVzLkNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uLnNldFRhZygndmlzaWJpbGl0eWNoYW5nZScsICdkb2N1bWVudC5oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVUcmFuc2FjdGlvbi5maW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIud2FybignW1RyYWNpbmddIENvdWxkIG5vdCBzZXQgdXAgYmFja2dyb3VuZCB0YWIgZGV0ZWN0aW9uIGR1ZSB0byBsYWNrIG9mIGdsb2JhbCBkb2N1bWVudCcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tncm91bmR0YWIuanMubWFwIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgdmFyIGJpbmRSZXBvcnRlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgbWV0cmljLCBwbywgb2JzZXJ2ZUFsbFVwZGF0ZXMpIHtcbiAgICB2YXIgcHJldlZhbHVlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwbyAmJiBtZXRyaWMuaXNGaW5hbCkge1xuICAgICAgICAgICAgcG8uZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRyaWMudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVBbGxVcGRhdGVzIHx8IG1ldHJpYy5pc0ZpbmFsIHx8IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWMuZGVsdGEgPSBtZXRyaWMudmFsdWUgLSAocHJldlZhbHVlIHx8IDApO1xuICAgICAgICAgICAgICAgIC8vIFJlcG9ydCB0aGUgbWV0cmljIGlmIHRoZXJlJ3MgYSBub24temVybyBkZWx0YSwgaWYgdGhlIG1ldHJpYyBpc1xuICAgICAgICAgICAgICAgIC8vIGZpbmFsLCBvciBpZiBubyBwcmV2aW91cyB2YWx1ZSBleGlzdHMgKHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgYmVjb21pbmcgaGlkZGVuIHdoZW4gdGhlIG1ldHJpYyB2YWx1ZSBpcyAwKS5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd2ViLXZpdGFscy9pc3N1ZXMvMTRcbiAgICAgICAgICAgICAgICBpZiAobWV0cmljLmRlbHRhIHx8IG1ldHJpYy5pc0ZpbmFsIHx8IHByZXZWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1ldHJpYyk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZSA9IG1ldHJpYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmRSZXBvcnRlci5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUGVyZm9ybWFudGx5IGdlbmVyYXRlIGEgdW5pcXVlLCAyNy1jaGFyIHN0cmluZyBieSBjb21iaW5pbmcgdGhlIGN1cnJlbnRcbiAqIHRpbWVzdGFtcCB3aXRoIGEgMTMtZGlnaXQgcmFuZG9tIG51bWJlci5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBnZW5lcmF0ZVVuaXF1ZUlEID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpICsgXCItXCIgKyAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZVVuaXF1ZUlELmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgZ2VuZXJhdGVVbmlxdWVJRCB9IGZyb20gJy4vZ2VuZXJhdGVVbmlxdWVJRCc7XG5leHBvcnQgdmFyIGluaXRNZXRyaWMgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IC0xOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBkZWx0YTogMCxcbiAgICAgICAgZW50cmllczogW10sXG4gICAgICAgIGlkOiBnZW5lcmF0ZVVuaXF1ZUlEKCksXG4gICAgICAgIGlzRmluYWw6IGZhbHNlLFxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdE1ldHJpYy5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGFrZXMgYSBwZXJmb3JtYW5jZSBlbnRyeSB0eXBlIGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uLCBhbmQgY3JlYXRlcyBhXG4gKiBgUGVyZm9ybWFuY2VPYnNlcnZlcmAgaW5zdGFuY2UgdGhhdCB3aWxsIG9ic2VydmUgdGhlIHNwZWNpZmllZCBlbnRyeSB0eXBlXG4gKiB3aXRoIGJ1ZmZlcmluZyBlbmFibGVkIGFuZCBjYWxsIHRoZSBjYWxsYmFjayBfZm9yIGVhY2ggZW50cnlfLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxzbyBmZWF0dXJlLWRldGVjdHMgZW50cnkgc3VwcG9ydCBhbmQgd3JhcHMgdGhlIGxvZ2ljIGluIGFcbiAqIHRyeS9jYXRjaCB0byBhdm9pZCBlcnJvcnMgaW4gdW5zdXBwb3J0aW5nIGJyb3dzZXJzLlxuICovXG5leHBvcnQgdmFyIG9ic2VydmUgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoUGVyZm9ybWFuY2VPYnNlcnZlci5zdXBwb3J0ZWRFbnRyeVR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgcG8gPSBuZXcgUGVyZm9ybWFuY2VPYnNlcnZlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5nZXRFbnRyaWVzKCkubWFwKGNhbGxiYWNrKTsgfSk7XG4gICAgICAgICAgICBwby5vYnNlcnZlKHsgdHlwZTogdHlwZSwgYnVmZmVyZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gcG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmUuanMubWFwIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaXNVbmxvYWRpbmcgPSBmYWxzZTtcbnZhciBsaXN0ZW5lcnNBZGRlZCA9IGZhbHNlO1xudmFyIG9uUGFnZUhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpc1VubG9hZGluZyA9ICFldmVudC5wZXJzaXN0ZWQ7XG59O1xudmFyIGFkZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIG9uUGFnZUhpZGUpO1xuICAgIC8vIGBiZWZvcmV1bmxvYWRgIGlzIG5lZWRlZCB0byBmaXggdGhpcyBidWc6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTg3NDA5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHsgfSk7XG59O1xuZXhwb3J0IHZhciBvbkhpZGRlbiA9IGZ1bmN0aW9uIChjYiwgb25jZSkge1xuICAgIGlmIChvbmNlID09PSB2b2lkIDApIHsgb25jZSA9IGZhbHNlOyB9XG4gICAgaWYgKCFsaXN0ZW5lcnNBZGRlZCkge1xuICAgICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgbGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBfYS50aW1lU3RhbXA7XG4gICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICBjYih7IHRpbWVTdGFtcDogdGltZVN0YW1wLCBpc1VubG9hZGluZzogaXNVbmxvYWRpbmcgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7IGNhcHR1cmU6IHRydWUsIG9uY2U6IG9uY2UgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25IaWRkZW4uanMubWFwIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBiaW5kUmVwb3J0ZXIgfSBmcm9tICcuL2xpYi9iaW5kUmVwb3J0ZXInO1xuaW1wb3J0IHsgaW5pdE1ldHJpYyB9IGZyb20gJy4vbGliL2luaXRNZXRyaWMnO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gJy4vbGliL29ic2VydmUnO1xuaW1wb3J0IHsgb25IaWRkZW4gfSBmcm9tICcuL2xpYi9vbkhpZGRlbic7XG5leHBvcnQgdmFyIGdldENMUyA9IGZ1bmN0aW9uIChvblJlcG9ydCwgcmVwb3J0QWxsQ2hhbmdlcykge1xuICAgIGlmIChyZXBvcnRBbGxDaGFuZ2VzID09PSB2b2lkIDApIHsgcmVwb3J0QWxsQ2hhbmdlcyA9IGZhbHNlOyB9XG4gICAgdmFyIG1ldHJpYyA9IGluaXRNZXRyaWMoJ0NMUycsIDApO1xuICAgIHZhciByZXBvcnQ7XG4gICAgdmFyIGVudHJ5SGFuZGxlciA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAvLyBPbmx5IGNvdW50IGxheW91dCBzaGlmdHMgd2l0aG91dCByZWNlbnQgdXNlciBpbnB1dC5cbiAgICAgICAgaWYgKCFlbnRyeS5oYWRSZWNlbnRJbnB1dCkge1xuICAgICAgICAgICAgbWV0cmljLnZhbHVlICs9IGVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgbWV0cmljLmVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICByZXBvcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvID0gb2JzZXJ2ZSgnbGF5b3V0LXNoaWZ0JywgZW50cnlIYW5kbGVyKTtcbiAgICBpZiAocG8pIHtcbiAgICAgICAgcmVwb3J0ID0gYmluZFJlcG9ydGVyKG9uUmVwb3J0LCBtZXRyaWMsIHBvLCByZXBvcnRBbGxDaGFuZ2VzKTtcbiAgICAgICAgb25IaWRkZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgaXNVbmxvYWRpbmcgPSBfYS5pc1VubG9hZGluZztcbiAgICAgICAgICAgIHBvLnRha2VSZWNvcmRzKCkubWFwKGVudHJ5SGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoaXNVbmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWMuaXNGaW5hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXBvcnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENMUy5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IG9uSGlkZGVuIH0gZnJvbSAnLi9vbkhpZGRlbic7XG52YXIgZmlyc3RIaWRkZW5UaW1lO1xuZXhwb3J0IHZhciBnZXRGaXJzdEhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmlyc3RIaWRkZW5UaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRvY3VtZW50IGlzIGhpZGRlbiB3aGVuIHRoaXMgY29kZSBydW5zLCBhc3N1bWUgaXQgd2FzIGhpZGRlblxuICAgICAgICAvLyBzaW5jZSBuYXZpZ2F0aW9uIHN0YXJ0LiBUaGlzIGlzbid0IGEgcGVyZmVjdCBoZXVyaXN0aWMsIGJ1dCBpdCdzIHRoZVxuICAgICAgICAvLyBiZXN0IHdlIGNhbiBkbyB1bnRpbCBhbiBBUEkgaXMgYXZhaWxhYmxlIHRvIHN1cHBvcnQgcXVlcnlpbmcgcGFzdFxuICAgICAgICAvLyB2aXNpYmlsaXR5U3RhdGUuXG4gICAgICAgIGZpcnN0SGlkZGVuVGltZSA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicgPyAwIDogSW5maW5pdHk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSBpZi93aGVuIHRoZSBkb2N1bWVudCBiZWNvbWVzIGhpZGRlbi5cbiAgICAgICAgb25IaWRkZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdGltZVN0YW1wID0gX2EudGltZVN0YW1wO1xuICAgICAgICAgICAgcmV0dXJuIChmaXJzdEhpZGRlblRpbWUgPSB0aW1lU3RhbXApO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdEhpZGRlblRpbWU7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGaXJzdEhpZGRlbi5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGJpbmRSZXBvcnRlciB9IGZyb20gJy4vbGliL2JpbmRSZXBvcnRlcic7XG5pbXBvcnQgeyBnZXRGaXJzdEhpZGRlbiB9IGZyb20gJy4vbGliL2dldEZpcnN0SGlkZGVuJztcbmltcG9ydCB7IGluaXRNZXRyaWMgfSBmcm9tICcuL2xpYi9pbml0TWV0cmljJztcbmltcG9ydCB7IG9ic2VydmUgfSBmcm9tICcuL2xpYi9vYnNlcnZlJztcbmltcG9ydCB7IG9uSGlkZGVuIH0gZnJvbSAnLi9saWIvb25IaWRkZW4nO1xuZXhwb3J0IHZhciBnZXRGSUQgPSBmdW5jdGlvbiAob25SZXBvcnQpIHtcbiAgICB2YXIgbWV0cmljID0gaW5pdE1ldHJpYygnRklEJyk7XG4gICAgdmFyIGZpcnN0SGlkZGVuID0gZ2V0Rmlyc3RIaWRkZW4oKTtcbiAgICB2YXIgZW50cnlIYW5kbGVyID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIC8vIE9ubHkgcmVwb3J0IGlmIHRoZSBwYWdlIHdhc24ndCBoaWRkZW4gcHJpb3IgdG8gdGhlIGZpcnN0IGlucHV0LlxuICAgICAgICBpZiAoZW50cnkuc3RhcnRUaW1lIDwgZmlyc3RIaWRkZW4udGltZVN0YW1wKSB7XG4gICAgICAgICAgICBtZXRyaWMudmFsdWUgPSBlbnRyeS5wcm9jZXNzaW5nU3RhcnQgLSBlbnRyeS5zdGFydFRpbWU7XG4gICAgICAgICAgICBtZXRyaWMuZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIG1ldHJpYy5pc0ZpbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcG9ydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG8gPSBvYnNlcnZlKCdmaXJzdC1pbnB1dCcsIGVudHJ5SGFuZGxlcik7XG4gICAgdmFyIHJlcG9ydCA9IGJpbmRSZXBvcnRlcihvblJlcG9ydCwgbWV0cmljLCBwbyk7XG4gICAgaWYgKHBvKSB7XG4gICAgICAgIG9uSGlkZGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBvLnRha2VSZWNvcmRzKCkubWFwKGVudHJ5SGFuZGxlcik7XG4gICAgICAgICAgICBwby5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHdpbmRvdy5wZXJmTWV0cmljcyAmJiB3aW5kb3cucGVyZk1ldHJpY3Mub25GaXJzdElucHV0RGVsYXkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5wZXJmTWV0cmljcy5vbkZpcnN0SW5wdXREZWxheShmdW5jdGlvbiAodmFsdWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXBvcnQgaWYgdGhlIHBhZ2Ugd2Fzbid0IGhpZGRlbiBwcmlvciB0byB0aGUgZmlyc3QgaW5wdXQuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRpbWVTdGFtcCA8IGZpcnN0SGlkZGVuLnRpbWVTdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRyaWMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWV0cmljLmlzRmluYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZXRyaWMuZW50cmllcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeVR5cGU6ICdmaXJzdC1pbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogZXZlbnQudGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTdGFydDogZXZlbnQudGltZVN0YW1wICsgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGSUQuanMubWFwIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgaW5wdXRQcm9taXNlO1xuZXhwb3J0IHZhciB3aGVuSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpbnB1dFByb21pc2UpIHtcbiAgICAgICAgaW5wdXRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3Njcm9sbCcsICdrZXlkb3duJywgJ3BvaW50ZXJkb3duJ10ubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCByLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb21pc2U7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2hlbklucHV0LmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgYmluZFJlcG9ydGVyIH0gZnJvbSAnLi9saWIvYmluZFJlcG9ydGVyJztcbmltcG9ydCB7IGdldEZpcnN0SGlkZGVuIH0gZnJvbSAnLi9saWIvZ2V0Rmlyc3RIaWRkZW4nO1xuaW1wb3J0IHsgaW5pdE1ldHJpYyB9IGZyb20gJy4vbGliL2luaXRNZXRyaWMnO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gJy4vbGliL29ic2VydmUnO1xuaW1wb3J0IHsgb25IaWRkZW4gfSBmcm9tICcuL2xpYi9vbkhpZGRlbic7XG5pbXBvcnQgeyB3aGVuSW5wdXQgfSBmcm9tICcuL2xpYi93aGVuSW5wdXQnO1xuZXhwb3J0IHZhciBnZXRMQ1AgPSBmdW5jdGlvbiAob25SZXBvcnQsIHJlcG9ydEFsbENoYW5nZXMpIHtcbiAgICBpZiAocmVwb3J0QWxsQ2hhbmdlcyA9PT0gdm9pZCAwKSB7IHJlcG9ydEFsbENoYW5nZXMgPSBmYWxzZTsgfVxuICAgIHZhciBtZXRyaWMgPSBpbml0TWV0cmljKCdMQ1AnKTtcbiAgICB2YXIgZmlyc3RIaWRkZW4gPSBnZXRGaXJzdEhpZGRlbigpO1xuICAgIHZhciByZXBvcnQ7XG4gICAgdmFyIGVudHJ5SGFuZGxlciA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAvLyBUaGUgc3RhcnRUaW1lIGF0dHJpYnV0ZSByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcmVuZGVyVGltZSBpZiBpdCBpcyBub3QgMCxcbiAgICAgICAgLy8gYW5kIHRoZSB2YWx1ZSBvZiB0aGUgbG9hZFRpbWUgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeS5zdGFydFRpbWU7XG4gICAgICAgIC8vIElmIHRoZSBwYWdlIHdhcyBoaWRkZW4gcHJpb3IgdG8gcGFpbnQgdGltZSBvZiB0aGUgZW50cnksXG4gICAgICAgIC8vIGlnbm9yZSBpdCBhbmQgbWFyayB0aGUgbWV0cmljIGFzIGZpbmFsLCBvdGhlcndpc2UgYWRkIHRoZSBlbnRyeS5cbiAgICAgICAgaWYgKHZhbHVlIDwgZmlyc3RIaWRkZW4udGltZVN0YW1wKSB7XG4gICAgICAgICAgICBtZXRyaWMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1ldHJpYy5lbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0cmljLmlzRmluYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcG9ydCgpO1xuICAgIH07XG4gICAgdmFyIHBvID0gb2JzZXJ2ZSgnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50JywgZW50cnlIYW5kbGVyKTtcbiAgICBpZiAocG8pIHtcbiAgICAgICAgcmVwb3J0ID0gYmluZFJlcG9ydGVyKG9uUmVwb3J0LCBtZXRyaWMsIHBvLCByZXBvcnRBbGxDaGFuZ2VzKTtcbiAgICAgICAgdmFyIG9uRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIW1ldHJpYy5pc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgcG8udGFrZVJlY29yZHMoKS5tYXAoZW50cnlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBtZXRyaWMuaXNGaW5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVwb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgd2hlbklucHV0KCkudGhlbihvbkZpbmFsKTtcbiAgICAgICAgb25IaWRkZW4ob25GaW5hbCwgdHJ1ZSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldExDUC5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IGdldEdsb2JhbE9iamVjdCB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgaW5pdE1ldHJpYyB9IGZyb20gJy4vbGliL2luaXRNZXRyaWMnO1xudmFyIGdsb2JhbCA9IGdldEdsb2JhbE9iamVjdCgpO1xudmFyIGFmdGVyTG9hZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIC8vIFF1ZXVlIGEgdGFzayBzbyB0aGUgY2FsbGJhY2sgcnVucyBhZnRlciBgbG9hZEV2ZW50RW5kYC5cbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVc2UgYHBhZ2VzaG93YCBzbyB0aGUgY2FsbGJhY2sgcnVucyBhZnRlciBgbG9hZEV2ZW50RW5kYC5cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBjYWxsYmFjayk7XG4gICAgfVxufTtcbnZhciBnZXROYXZpZ2F0aW9uRW50cnlGcm9tUGVyZm9ybWFuY2VUaW1pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVhbGx5IGFubm95aW5nIHRoYXQgVHlwZVNjcmlwdCBlcnJvcnMgd2hlbiB1c2luZyBgUGVyZm9ybWFuY2VUaW1pbmdgLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgIHZhciB0aW1pbmcgPSBnbG9iYWwucGVyZm9ybWFuY2UudGltaW5nO1xuICAgIHZhciBuYXZpZ2F0aW9uRW50cnkgPSB7XG4gICAgICAgIGVudHJ5VHlwZTogJ25hdmlnYXRpb24nLFxuICAgICAgICBzdGFydFRpbWU6IDAsXG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGltaW5nKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICduYXZpZ2F0aW9uU3RhcnQnICYmIGtleSAhPT0gJ3RvSlNPTicpIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb25FbnRyeVtrZXldID0gTWF0aC5tYXgodGltaW5nW2tleV0gLSB0aW1pbmcubmF2aWdhdGlvblN0YXJ0LCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmF2aWdhdGlvbkVudHJ5O1xufTtcbmV4cG9ydCB2YXIgZ2V0VFRGQiA9IGZ1bmN0aW9uIChvblJlcG9ydCkge1xuICAgIHZhciBtZXRyaWMgPSBpbml0TWV0cmljKCdUVEZCJyk7XG4gICAgYWZ0ZXJMb2FkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgTmF2aWdhdGlvblRpbWluZyBMMiBlbnRyeSBpZiBhdmFpbGFibGUuXG4gICAgICAgICAgICB2YXIgbmF2aWdhdGlvbkVudHJ5ID0gZ2xvYmFsLnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKVswXSB8fCBnZXROYXZpZ2F0aW9uRW50cnlGcm9tUGVyZm9ybWFuY2VUaW1pbmcoKTtcbiAgICAgICAgICAgIG1ldHJpYy52YWx1ZSA9IG1ldHJpYy5kZWx0YSA9IG5hdmlnYXRpb25FbnRyeS5yZXNwb25zZVN0YXJ0O1xuICAgICAgICAgICAgbWV0cmljLmVudHJpZXMgPSBbbmF2aWdhdGlvbkVudHJ5XTtcbiAgICAgICAgICAgIG9uUmVwb3J0KG1ldHJpYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICB9XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0VFRGQi5qcy5tYXAiLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luLCBnZXRHbG9iYWxPYmplY3QsIGxvZ2dlciB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgbXNUb1NlYyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldENMUyB9IGZyb20gJy4vd2ViLXZpdGFscy9nZXRDTFMnO1xuaW1wb3J0IHsgZ2V0RklEIH0gZnJvbSAnLi93ZWItdml0YWxzL2dldEZJRCc7XG5pbXBvcnQgeyBnZXRMQ1AgfSBmcm9tICcuL3dlYi12aXRhbHMvZ2V0TENQJztcbmltcG9ydCB7IGdldFRURkIgfSBmcm9tICcuL3dlYi12aXRhbHMvZ2V0VFRGQic7XG5pbXBvcnQgeyBnZXRGaXJzdEhpZGRlbiB9IGZyb20gJy4vd2ViLXZpdGFscy9saWIvZ2V0Rmlyc3RIaWRkZW4nO1xudmFyIGdsb2JhbCA9IGdldEdsb2JhbE9iamVjdCgpO1xuLyoqIENsYXNzIHRyYWNraW5nIG1ldHJpY3MgICovXG52YXIgTWV0cmljc0luc3RydW1lbnRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXRyaWNzSW5zdHJ1bWVudGF0aW9uKCkge1xuICAgICAgICB0aGlzLl9tZWFzdXJlbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGVyZm9ybWFuY2VDdXJzb3IgPSAwO1xuICAgICAgICBpZiAoZ2xvYmFsICYmIGdsb2JhbC5wZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbC5wZXJmb3JtYW5jZS5tYXJrKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsLnBlcmZvcm1hbmNlLm1hcmsoJ3NlbnRyeS10cmFjaW5nLWluaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQ0xTKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFja0xDUCgpO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tGSUQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrVFRGQigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBBZGQgcGVyZm9ybWFuY2UgcmVsYXRlZCBzcGFucyB0byBhIHRyYW5zYWN0aW9uICovXG4gICAgTWV0cmljc0luc3RydW1lbnRhdGlvbi5wcm90b3R5cGUuYWRkUGVyZm9ybWFuY2VFbnRyaWVzID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZ2xvYmFsIHx8ICFnbG9iYWwucGVyZm9ybWFuY2UgfHwgIWdsb2JhbC5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzIHx8ICFicm93c2VyUGVyZm9ybWFuY2VUaW1lT3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBHYXRla2VlcGVyIGlmIHBlcmZvcm1hbmNlIEFQSSBub3QgYXZhaWxhYmxlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZygnW1RyYWNpbmddIEFkZGluZyAmIGFkanVzdGluZyBzcGFucyB1c2luZyBQZXJmb3JtYW5jZSBBUEknKTtcbiAgICAgICAgdmFyIHRpbWVPcmlnaW4gPSBtc1RvU2VjKGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4pO1xuICAgICAgICB2YXIgZW50cnlTY3JpcHRTcmM7XG4gICAgICAgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ28gdGhyb3VnaCBhbGwgc2NyaXB0cyBvbiB0aGUgcGFnZSBhbmQgbG9vayBmb3IgJ2RhdGEtZW50cnknXG4gICAgICAgICAgICAgICAgLy8gV2UgcmVtZW1iZXIgdGhlIG5hbWUgYW5kIG1lYXN1cmUgdGhlIHRpbWUgYmV0d2VlbiB0aGlzIHNjcmlwdCBmaW5pc2hlZCBsb2FkaW5nIGFuZFxuICAgICAgICAgICAgICAgIC8vIG91ciBtYXJrICdzZW50cnktdHJhY2luZy1pbml0J1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5zY3JpcHRzW2ldLmRhdGFzZXQuZW50cnkgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeVNjcmlwdFNyYyA9IGRvY3VtZW50LnNjcmlwdHNbaV0uc3JjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5U2NyaXB0U3RhcnRUaW1lc3RhbXA7XG4gICAgICAgIHZhciB0cmFjaW5nSW5pdE1hcmtTdGFydFRpbWU7XG4gICAgICAgIGdsb2JhbC5wZXJmb3JtYW5jZVxuICAgICAgICAgICAgLmdldEVudHJpZXMoKVxuICAgICAgICAgICAgLnNsaWNlKHRoaXMuX3BlcmZvcm1hbmNlQ3Vyc29yKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gbXNUb1NlYyhlbnRyeS5zdGFydFRpbWUpO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gbXNUb1NlYyhlbnRyeS5kdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ub3AgPT09ICduYXZpZ2F0aW9uJyAmJiB0aW1lT3JpZ2luICsgc3RhcnRUaW1lIDwgdHJhbnNhY3Rpb24uc3RhcnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGVudHJ5LmVudHJ5VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25hdmlnYXRpb24nOlxuICAgICAgICAgICAgICAgICAgICBhZGROYXZpZ2F0aW9uU3BhbnModHJhbnNhY3Rpb24sIGVudHJ5LCB0aW1lT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFyayc6XG4gICAgICAgICAgICAgICAgY2FzZSAncGFpbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21lYXN1cmUnOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9IGFkZE1lYXN1cmVTcGFucyh0cmFuc2FjdGlvbiwgZW50cnksIHN0YXJ0VGltZSwgZHVyYXRpb24sIHRpbWVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2luZ0luaXRNYXJrU3RhcnRUaW1lID09PSB1bmRlZmluZWQgJiYgZW50cnkubmFtZSA9PT0gJ3NlbnRyeS10cmFjaW5nLWluaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjaW5nSW5pdE1hcmtTdGFydFRpbWUgPSBzdGFydFRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHdlYiB2aXRhbHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0SGlkZGVuID0gZ2V0Rmlyc3RIaWRkZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBvcnQgaWYgdGhlIHBhZ2Ugd2Fzbid0IGhpZGRlbiBwcmlvciB0byB0aGUgd2ViIHZpdGFsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVjb3JkID0gZW50cnkuc3RhcnRUaW1lIDwgZmlyc3RIaWRkZW4udGltZVN0YW1wO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubmFtZSA9PT0gJ2ZpcnN0LXBhaW50JyAmJiBzaG91bGRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coJ1tNZWFzdXJlbWVudHNdIEFkZGluZyBGUCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21lYXN1cmVtZW50c1snZnAnXSA9IHsgdmFsdWU6IGVudHJ5LnN0YXJ0VGltZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21lYXN1cmVtZW50c1snbWFyay5mcCddID0geyB2YWx1ZTogc3RhcnRUaW1lc3RhbXAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkubmFtZSA9PT0gJ2ZpcnN0LWNvbnRlbnRmdWwtcGFpbnQnICYmIHNob3VsZFJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnW01lYXN1cmVtZW50c10gQWRkaW5nIEZDUCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21lYXN1cmVtZW50c1snZmNwJ10gPSB7IHZhbHVlOiBlbnRyeS5zdGFydFRpbWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tZWFzdXJlbWVudHNbJ21hcmsuZmNwJ10gPSB7IHZhbHVlOiBzdGFydFRpbWVzdGFtcCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdyZXNvdXJjZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlTmFtZSA9IGVudHJ5Lm5hbWUucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ub3JpZ2luLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRUaW1lc3RhbXAgPSBhZGRSZXNvdXJjZVNwYW5zKHRyYW5zYWN0aW9uLCBlbnRyeSwgcmVzb3VyY2VOYW1lLCBzdGFydFRpbWUsIGR1cmF0aW9uLCB0aW1lT3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVtZW1iZXIgdGhlIGVudHJ5IHNjcmlwdCBlbmQgdGltZSB0byBjYWxjdWxhdGUgdGhlIGRpZmZlcmVuY2UgdG8gdGhlIGZpcnN0IGluaXQgbWFya1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnlTY3JpcHRTdGFydFRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkICYmIChlbnRyeVNjcmlwdFNyYyB8fCAnJykuaW5kZXhPZihyZXNvdXJjZU5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5U2NyaXB0U3RhcnRUaW1lc3RhbXAgPSBlbmRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG90aGVyIGVudHJ5IHR5cGVzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVudHJ5U2NyaXB0U3RhcnRUaW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiB0cmFjaW5nSW5pdE1hcmtTdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3N0YXJ0Q2hpbGQodHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ2V2YWx1YXRpb24nLFxuICAgICAgICAgICAgICAgIGVuZFRpbWVzdGFtcDogdHJhY2luZ0luaXRNYXJrU3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIG9wOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcDogZW50cnlTY3JpcHRTdGFydFRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlcmZvcm1hbmNlQ3Vyc29yID0gTWF0aC5tYXgocGVyZm9ybWFuY2UuZ2V0RW50cmllcygpLmxlbmd0aCAtIDEsIDApO1xuICAgICAgICB0aGlzLl90cmFja05hdmlnYXRvcih0cmFuc2FjdGlvbik7XG4gICAgICAgIC8vIE1lYXN1cmVtZW50cyBhcmUgb25seSBhdmFpbGFibGUgZm9yIHBhZ2Vsb2FkIHRyYW5zYWN0aW9uc1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ub3AgPT09ICdwYWdlbG9hZCcpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBhcHBsaWNhYmxlIHdlYiB2aXRhbCB2YWx1ZXMgdG8gYmUgcmVsYXRpdmUgdG8gdHJhbnNhY3Rpb24uc3RhcnRUaW1lc3RhbXBcbiAgICAgICAgICAgIHZhciB0aW1lT3JpZ2luXzEgPSBtc1RvU2VjKGJyb3dzZXJQZXJmb3JtYW5jZVRpbWVPcmlnaW4pO1xuICAgICAgICAgICAgWydmY3AnLCAnZnAnLCAnbGNwJywgJ3R0ZmInXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fbWVhc3VyZW1lbnRzW25hbWVdIHx8IHRpbWVPcmlnaW5fMSA+PSB0cmFuc2FjdGlvbi5zdGFydFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSB3ZWIgdml0YWxzLCBmY3AsIGZwLCBsY3AsIGFuZCB0dGZiLCBhbGwgbWVhc3VyZSByZWxhdGl2ZSB0byB0aW1lT3JpZ2luLlxuICAgICAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRpbWVPcmlnaW4gaXMgbm90IGNhcHR1cmVkIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gc3BhbiBkYXRhLCBzbyB0aGVzZSB3ZWIgdml0YWxzIHdpbGwgbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGFkanVzdGVkIHRvIGJlIHJlbGF0aXZlIHRvIHRyYW5zYWN0aW9uLnN0YXJ0VGltZXN0YW1wLlxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IF90aGlzLl9tZWFzdXJlbWVudHNbbmFtZV0udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG1lYXN1cmVtZW50VGltZXN0YW1wID0gdGltZU9yaWdpbl8xICsgbXNUb1NlYyhvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplZFZhbHVlIHNob3VsZCBiZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gTWF0aC5hYnMoKG1lYXN1cmVtZW50VGltZXN0YW1wIC0gdHJhbnNhY3Rpb24uc3RhcnRUaW1lc3RhbXApICogMTAwMCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gbm9ybWFsaXplZFZhbHVlIC0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIltNZWFzdXJlbWVudHNdIE5vcm1hbGl6ZWQgXCIgKyBuYW1lICsgXCIgZnJvbSBcIiArIG9sZFZhbHVlICsgXCIgdG8gXCIgKyBub3JtYWxpemVkVmFsdWUgKyBcIiAoXCIgKyBkZWx0YSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWVhc3VyZW1lbnRzW25hbWVdLnZhbHVlID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWVhc3VyZW1lbnRzWydtYXJrLmZpZCddICYmIHRoaXMuX21lYXN1cmVtZW50c1snZmlkJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgc3BhbiBmb3IgRklEXG4gICAgICAgICAgICAgICAgX3N0YXJ0Q2hpbGQodHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdmaXJzdCBpbnB1dCBkZWxheScsXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWVzdGFtcDogdGhpcy5fbWVhc3VyZW1lbnRzWydtYXJrLmZpZCddLnZhbHVlICsgbXNUb1NlYyh0aGlzLl9tZWFzdXJlbWVudHNbJ2ZpZCddLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgb3A6ICd3ZWIudml0YWxzJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IHRoaXMuX21lYXN1cmVtZW50c1snbWFyay5maWQnXS52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNldE1lYXN1cmVtZW50cyh0aGlzLl9tZWFzdXJlbWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogU3RhcnRzIHRyYWNraW5nIHRoZSBDdW11bGF0aXZlIExheW91dCBTaGlmdCBvbiB0aGUgY3VycmVudCBwYWdlLiAqL1xuICAgIE1ldHJpY3NJbnN0cnVtZW50YXRpb24ucHJvdG90eXBlLl90cmFja0NMUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZ2V0Q0xTKGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG1ldHJpYy5lbnRyaWVzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1tNZWFzdXJlbWVudHNdIEFkZGluZyBDTFMnKTtcbiAgICAgICAgICAgIF90aGlzLl9tZWFzdXJlbWVudHNbJ2NscyddID0geyB2YWx1ZTogbWV0cmljLnZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIHVzZXIgYWdlbnQuXG4gICAgICovXG4gICAgTWV0cmljc0luc3RydW1lbnRhdGlvbi5wcm90b3R5cGUuX3RyYWNrTmF2aWdhdG9yID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuICAgICAgICBpZiAoIW5hdmlnYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrIG5ldHdvcmsgY29ubmVjdGl2aXR5XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gbmF2aWdhdG9yLmNvbm5lY3Rpb247XG4gICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5lZmZlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0VGFnKCdlZmZlY3RpdmVDb25uZWN0aW9uVHlwZScsIGNvbm5lY3Rpb24uZWZmZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0VGFnKCdjb25uZWN0aW9uVHlwZScsIGNvbm5lY3Rpb24udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNNZWFzdXJlbWVudFZhbHVlKGNvbm5lY3Rpb24ucnR0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21lYXN1cmVtZW50c1snY29ubmVjdGlvbi5ydHQnXSA9IHsgdmFsdWU6IGNvbm5lY3Rpb24ucnR0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNNZWFzdXJlbWVudFZhbHVlKGNvbm5lY3Rpb24uZG93bmxpbmspKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVhc3VyZW1lbnRzWydjb25uZWN0aW9uLmRvd25saW5rJ10gPSB7IHZhbHVlOiBjb25uZWN0aW9uLmRvd25saW5rIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWVhc3VyZW1lbnRWYWx1ZShuYXZpZ2F0b3IuZGV2aWNlTWVtb3J5KSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0VGFnKCdkZXZpY2VNZW1vcnknLCBTdHJpbmcobmF2aWdhdG9yLmRldmljZU1lbW9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01lYXN1cmVtZW50VmFsdWUobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5zZXRUYWcoJ2hhcmR3YXJlQ29uY3VycmVuY3knLCBTdHJpbmcobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFN0YXJ0cyB0cmFja2luZyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IG9uIHRoZSBjdXJyZW50IHBhZ2UuICovXG4gICAgTWV0cmljc0luc3RydW1lbnRhdGlvbi5wcm90b3R5cGUuX3RyYWNrTENQID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnZXRMQ1AoZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbWV0cmljLmVudHJpZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWVPcmlnaW4gPSBtc1RvU2VjKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG1zVG9TZWMoZW50cnkuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1tNZWFzdXJlbWVudHNdIEFkZGluZyBMQ1AnKTtcbiAgICAgICAgICAgIF90aGlzLl9tZWFzdXJlbWVudHNbJ2xjcCddID0geyB2YWx1ZTogbWV0cmljLnZhbHVlIH07XG4gICAgICAgICAgICBfdGhpcy5fbWVhc3VyZW1lbnRzWydtYXJrLmxjcCddID0geyB2YWx1ZTogdGltZU9yaWdpbiArIHN0YXJ0VGltZSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBTdGFydHMgdHJhY2tpbmcgdGhlIEZpcnN0IElucHV0IERlbGF5IG9uIHRoZSBjdXJyZW50IHBhZ2UuICovXG4gICAgTWV0cmljc0luc3RydW1lbnRhdGlvbi5wcm90b3R5cGUuX3RyYWNrRklEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnZXRGSUQoZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbWV0cmljLmVudHJpZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbWVPcmlnaW4gPSBtc1RvU2VjKHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG1zVG9TZWMoZW50cnkuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ1tNZWFzdXJlbWVudHNdIEFkZGluZyBGSUQnKTtcbiAgICAgICAgICAgIF90aGlzLl9tZWFzdXJlbWVudHNbJ2ZpZCddID0geyB2YWx1ZTogbWV0cmljLnZhbHVlIH07XG4gICAgICAgICAgICBfdGhpcy5fbWVhc3VyZW1lbnRzWydtYXJrLmZpZCddID0geyB2YWx1ZTogdGltZU9yaWdpbiArIHN0YXJ0VGltZSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBTdGFydHMgdHJhY2tpbmcgdGhlIFRpbWUgdG8gRmlyc3QgQnl0ZSBvbiB0aGUgY3VycmVudCBwYWdlLiAqL1xuICAgIE1ldHJpY3NJbnN0cnVtZW50YXRpb24ucHJvdG90eXBlLl90cmFja1RURkIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdldFRURkIoZnVuY3Rpb24gKG1ldHJpYykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbWV0cmljLmVudHJpZXMucG9wKCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZygnW01lYXN1cmVtZW50c10gQWRkaW5nIFRURkInKTtcbiAgICAgICAgICAgIF90aGlzLl9tZWFzdXJlbWVudHNbJ3R0ZmInXSA9IHsgdmFsdWU6IG1ldHJpYy52YWx1ZSB9O1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgdGltZSBzcGVudCBtYWtpbmcgdGhlIHJlcXVlc3QgYW5kIHJlY2VpdmluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIHZhciByZXF1ZXN0VGltZSA9IG1ldHJpYy52YWx1ZSAtIChfYSA9IG1ldHJpYy5lbnRyaWVzWzBdLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZW50cnkpKS5yZXF1ZXN0U3RhcnQ7XG4gICAgICAgICAgICBfdGhpcy5fbWVhc3VyZW1lbnRzWyd0dGZiLnJlcXVlc3RUaW1lJ10gPSB7IHZhbHVlOiByZXF1ZXN0VGltZSB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNZXRyaWNzSW5zdHJ1bWVudGF0aW9uO1xufSgpKTtcbmV4cG9ydCB7IE1ldHJpY3NJbnN0cnVtZW50YXRpb24gfTtcbi8qKiBJbnN0cnVtZW50IG5hdmlnYXRpb24gZW50cmllcyAqL1xuZnVuY3Rpb24gYWRkTmF2aWdhdGlvblNwYW5zKHRyYW5zYWN0aW9uLCBlbnRyeSwgdGltZU9yaWdpbikge1xuICAgIGFkZFBlcmZvcm1hbmNlTmF2aWdhdGlvblRpbWluZyh0cmFuc2FjdGlvbiwgZW50cnksICd1bmxvYWRFdmVudCcsIHRpbWVPcmlnaW4pO1xuICAgIGFkZFBlcmZvcm1hbmNlTmF2aWdhdGlvblRpbWluZyh0cmFuc2FjdGlvbiwgZW50cnksICdyZWRpcmVjdCcsIHRpbWVPcmlnaW4pO1xuICAgIGFkZFBlcmZvcm1hbmNlTmF2aWdhdGlvblRpbWluZyh0cmFuc2FjdGlvbiwgZW50cnksICdkb21Db250ZW50TG9hZGVkRXZlbnQnLCB0aW1lT3JpZ2luKTtcbiAgICBhZGRQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmcodHJhbnNhY3Rpb24sIGVudHJ5LCAnbG9hZEV2ZW50JywgdGltZU9yaWdpbik7XG4gICAgYWRkUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nKHRyYW5zYWN0aW9uLCBlbnRyeSwgJ2Nvbm5lY3QnLCB0aW1lT3JpZ2luKTtcbiAgICBhZGRQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmcodHJhbnNhY3Rpb24sIGVudHJ5LCAnc2VjdXJlQ29ubmVjdGlvbicsIHRpbWVPcmlnaW4sICdjb25uZWN0RW5kJyk7XG4gICAgYWRkUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nKHRyYW5zYWN0aW9uLCBlbnRyeSwgJ2ZldGNoJywgdGltZU9yaWdpbiwgJ2RvbWFpbkxvb2t1cFN0YXJ0Jyk7XG4gICAgYWRkUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nKHRyYW5zYWN0aW9uLCBlbnRyeSwgJ2RvbWFpbkxvb2t1cCcsIHRpbWVPcmlnaW4pO1xuICAgIGFkZFJlcXVlc3QodHJhbnNhY3Rpb24sIGVudHJ5LCB0aW1lT3JpZ2luKTtcbn1cbi8qKiBDcmVhdGUgbWVhc3VyZSByZWxhdGVkIHNwYW5zICovXG5mdW5jdGlvbiBhZGRNZWFzdXJlU3BhbnModHJhbnNhY3Rpb24sIGVudHJ5LCBzdGFydFRpbWUsIGR1cmF0aW9uLCB0aW1lT3JpZ2luKSB7XG4gICAgdmFyIG1lYXN1cmVTdGFydFRpbWVzdGFtcCA9IHRpbWVPcmlnaW4gKyBzdGFydFRpbWU7XG4gICAgdmFyIG1lYXN1cmVFbmRUaW1lc3RhbXAgPSBtZWFzdXJlU3RhcnRUaW1lc3RhbXAgKyBkdXJhdGlvbjtcbiAgICBfc3RhcnRDaGlsZCh0cmFuc2FjdGlvbiwge1xuICAgICAgICBkZXNjcmlwdGlvbjogZW50cnkubmFtZSxcbiAgICAgICAgZW5kVGltZXN0YW1wOiBtZWFzdXJlRW5kVGltZXN0YW1wLFxuICAgICAgICBvcDogZW50cnkuZW50cnlUeXBlLFxuICAgICAgICBzdGFydFRpbWVzdGFtcDogbWVhc3VyZVN0YXJ0VGltZXN0YW1wLFxuICAgIH0pO1xuICAgIHJldHVybiBtZWFzdXJlU3RhcnRUaW1lc3RhbXA7XG59XG4vKiogQ3JlYXRlIHJlc291cmNlLXJlbGF0ZWQgc3BhbnMgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXNvdXJjZVNwYW5zKHRyYW5zYWN0aW9uLCBlbnRyeSwgcmVzb3VyY2VOYW1lLCBzdGFydFRpbWUsIGR1cmF0aW9uLCB0aW1lT3JpZ2luKSB7XG4gICAgLy8gd2UgYWxyZWFkeSBpbnN0cnVtZW50IGJhc2VkIG9uIGZldGNoIGFuZCB4aHIsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAvLyBkdXBsaWNhdGUgc3BhbnMgaGVyZS5cbiAgICBpZiAoZW50cnkuaW5pdGlhdG9yVHlwZSA9PT0gJ3htbGh0dHByZXF1ZXN0JyB8fCBlbnRyeS5pbml0aWF0b3JUeXBlID09PSAnZmV0Y2gnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0ge307XG4gICAgaWYgKCd0cmFuc2ZlclNpemUnIGluIGVudHJ5KSB7XG4gICAgICAgIGRhdGFbJ1RyYW5zZmVyIFNpemUnXSA9IGVudHJ5LnRyYW5zZmVyU2l6ZTtcbiAgICB9XG4gICAgaWYgKCdlbmNvZGVkQm9keVNpemUnIGluIGVudHJ5KSB7XG4gICAgICAgIGRhdGFbJ0VuY29kZWQgQm9keSBTaXplJ10gPSBlbnRyeS5lbmNvZGVkQm9keVNpemU7XG4gICAgfVxuICAgIGlmICgnZGVjb2RlZEJvZHlTaXplJyBpbiBlbnRyeSkge1xuICAgICAgICBkYXRhWydEZWNvZGVkIEJvZHkgU2l6ZSddID0gZW50cnkuZGVjb2RlZEJvZHlTaXplO1xuICAgIH1cbiAgICB2YXIgc3RhcnRUaW1lc3RhbXAgPSB0aW1lT3JpZ2luICsgc3RhcnRUaW1lO1xuICAgIHZhciBlbmRUaW1lc3RhbXAgPSBzdGFydFRpbWVzdGFtcCArIGR1cmF0aW9uO1xuICAgIF9zdGFydENoaWxkKHRyYW5zYWN0aW9uLCB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiByZXNvdXJjZU5hbWUsXG4gICAgICAgIGVuZFRpbWVzdGFtcDogZW5kVGltZXN0YW1wLFxuICAgICAgICBvcDogZW50cnkuaW5pdGlhdG9yVHlwZSA/IFwicmVzb3VyY2UuXCIgKyBlbnRyeS5pbml0aWF0b3JUeXBlIDogJ3Jlc291cmNlJyxcbiAgICAgICAgc3RhcnRUaW1lc3RhbXA6IHN0YXJ0VGltZXN0YW1wLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgIH0pO1xuICAgIHJldHVybiBlbmRUaW1lc3RhbXA7XG59XG4vKiogQ3JlYXRlIHBlcmZvcm1hbmNlIG5hdmlnYXRpb24gcmVsYXRlZCBzcGFucyAqL1xuZnVuY3Rpb24gYWRkUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nKHRyYW5zYWN0aW9uLCBlbnRyeSwgZXZlbnQsIHRpbWVPcmlnaW4sIGV2ZW50RW5kKSB7XG4gICAgdmFyIGVuZCA9IGV2ZW50RW5kID8gZW50cnlbZXZlbnRFbmRdIDogZW50cnlbZXZlbnQgKyBcIkVuZFwiXTtcbiAgICB2YXIgc3RhcnQgPSBlbnRyeVtldmVudCArIFwiU3RhcnRcIl07XG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3N0YXJ0Q2hpbGQodHJhbnNhY3Rpb24sIHtcbiAgICAgICAgb3A6ICdicm93c2VyJyxcbiAgICAgICAgZGVzY3JpcHRpb246IGV2ZW50LFxuICAgICAgICBzdGFydFRpbWVzdGFtcDogdGltZU9yaWdpbiArIG1zVG9TZWMoc3RhcnQpLFxuICAgICAgICBlbmRUaW1lc3RhbXA6IHRpbWVPcmlnaW4gKyBtc1RvU2VjKGVuZCksXG4gICAgfSk7XG59XG4vKiogQ3JlYXRlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJlbGF0ZWQgc3BhbnMgKi9cbmZ1bmN0aW9uIGFkZFJlcXVlc3QodHJhbnNhY3Rpb24sIGVudHJ5LCB0aW1lT3JpZ2luKSB7XG4gICAgX3N0YXJ0Q2hpbGQodHJhbnNhY3Rpb24sIHtcbiAgICAgICAgb3A6ICdicm93c2VyJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdyZXF1ZXN0JyxcbiAgICAgICAgc3RhcnRUaW1lc3RhbXA6IHRpbWVPcmlnaW4gKyBtc1RvU2VjKGVudHJ5LnJlcXVlc3RTdGFydCksXG4gICAgICAgIGVuZFRpbWVzdGFtcDogdGltZU9yaWdpbiArIG1zVG9TZWMoZW50cnkucmVzcG9uc2VFbmQpLFxuICAgIH0pO1xuICAgIF9zdGFydENoaWxkKHRyYW5zYWN0aW9uLCB7XG4gICAgICAgIG9wOiAnYnJvd3NlcicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAncmVzcG9uc2UnLFxuICAgICAgICBzdGFydFRpbWVzdGFtcDogdGltZU9yaWdpbiArIG1zVG9TZWMoZW50cnkucmVzcG9uc2VTdGFydCksXG4gICAgICAgIGVuZFRpbWVzdGFtcDogdGltZU9yaWdpbiArIG1zVG9TZWMoZW50cnkucmVzcG9uc2VFbmQpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc3RhcnQgY2hpbGQgb24gdHJhbnNhY3Rpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHdpbGxcbiAqIHVzZSB0aGUgc3RhcnQgdGltZXN0YW1wIG9mIHRoZSBjcmVhdGVkIGNoaWxkIHNwYW4gaWYgaXQgaXMgZWFybGllciB0aGFuIHRoZSB0cmFuc2FjdGlvbnMgYWN0dWFsXG4gKiBzdGFydCB0aW1lc3RhbXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RhcnRDaGlsZCh0cmFuc2FjdGlvbiwgX2EpIHtcbiAgICB2YXIgc3RhcnRUaW1lc3RhbXAgPSBfYS5zdGFydFRpbWVzdGFtcCwgY3R4ID0gX19yZXN0KF9hLCBbXCJzdGFydFRpbWVzdGFtcFwiXSk7XG4gICAgaWYgKHN0YXJ0VGltZXN0YW1wICYmIHRyYW5zYWN0aW9uLnN0YXJ0VGltZXN0YW1wID4gc3RhcnRUaW1lc3RhbXApIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3RhcnRUaW1lc3RhbXAgPSBzdGFydFRpbWVzdGFtcDtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoX19hc3NpZ24oeyBzdGFydFRpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXAgfSwgY3R4KSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgbWVhc3VyZW1lbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGlzTWVhc3VyZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldHJpY3MuanMubWFwIiwiaW1wb3J0IHsgYWRkSW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgZ2V0R2xvYmFsT2JqZWN0LCBsb2dnZXIgfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbnZhciBnbG9iYWwgPSBnZXRHbG9iYWxPYmplY3QoKTtcbi8qKlxuICogRGVmYXVsdCBmdW5jdGlvbiBpbXBsZW1lbnRpbmcgcGFnZWxvYWQgYW5kIG5hdmlnYXRpb24gdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnN0cnVtZW50Um91dGluZ1dpdGhEZWZhdWx0cyhjdXN0b21TdGFydFRyYW5zYWN0aW9uLCBzdGFydFRyYW5zYWN0aW9uT25QYWdlTG9hZCwgc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2UpIHtcbiAgICBpZiAoc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQgPT09IHZvaWQgMCkgeyBzdGFydFRyYW5zYWN0aW9uT25QYWdlTG9hZCA9IHRydWU7IH1cbiAgICBpZiAoc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2UgPT09IHZvaWQgMCkgeyBzdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZSA9IHRydWU7IH1cbiAgICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSByb3V0aW5nIGluc3RydW1lbnRhdGlvbiBkdWUgdG8gaW52YWxpZCBsb2NhdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFydGluZ1VybCA9IGdsb2JhbC5sb2NhdGlvbi5ocmVmO1xuICAgIHZhciBhY3RpdmVUcmFuc2FjdGlvbjtcbiAgICBpZiAoc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQpIHtcbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24gPSBjdXN0b21TdGFydFRyYW5zYWN0aW9uKHsgbmFtZTogZ2xvYmFsLmxvY2F0aW9uLnBhdGhuYW1lLCBvcDogJ3BhZ2Vsb2FkJyB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgIGFkZEluc3RydW1lbnRhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0byA9IF9hLnRvLCBmcm9tID0gX2EuZnJvbTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIGVhcmx5IHJldHVybiBpcyB0aGVyZSB0byBhY2NvdW50IGZvciBzb21lIGNhc2VzIHdoZXJlIGEgbmF2aWdhdGlvbiB0cmFuc2FjdGlvbiBzdGFydHMgcmlnaHQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgKiBsb25nLXJ1bm5pbmcgcGFnZWxvYWQuIFdlIG1ha2Ugc3VyZSB0aGF0IGlmIGBmcm9tYCBpcyB1bmRlZmluZWQgYW5kIGEgdmFsaWQgYHN0YXJ0aW5nVVJMYCBleGlzdHMsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICogY3JlYXRlIGFuIHVuZWNjZXNzYXJ5IG5hdmlnYXRpb24gdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdhcyBoYXJkIHRvIGR1cGxpY2F0ZSwgYnV0IHRoaXMgYmVoYXZpb3Igc3RvcHBlZCBhcyBzb29uIGFzIHRoaXMgZml4IHdhcyBhcHBsaWVkLiBUaGlzIGlzc3VlIG1pZ2h0IGFsc29cbiAgICAgICAgICAgICAgICAgKiBvbmx5IGJlIGNhdXNlZCBpbiBjZXJ0YWluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyB3aGVyZSB0aGUgdXNhZ2Ugb2YgYSBob3QgbW9kdWxlIHJlbG9hZGVyIGlzIGNhdXNpbmdcbiAgICAgICAgICAgICAgICAgKiBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCAmJiBzdGFydGluZ1VybCAmJiBzdGFydGluZ1VybC5pbmRleE9mKHRvKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdVcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gIT09IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0aW5nVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbVHJhY2luZ10gRmluaXNoaW5nIGN1cnJlbnQgdHJhbnNhY3Rpb24gd2l0aCBvcDogXCIgKyBhY3RpdmVUcmFuc2FjdGlvbi5vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIG9wZW4gdHJhbnNhY3Rpb24gb24gdGhlIHNjb3BlLCB3ZSBuZWVkIHRvIGZpbmlzaCBpdCBiZWZvcmUgY3JlYXRpbmcgYW4gbmV3IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uID0gY3VzdG9tU3RhcnRUcmFuc2FjdGlvbih7IG5hbWU6IGdsb2JhbC5sb2NhdGlvbi5wYXRobmFtZSwgb3A6ICduYXZpZ2F0aW9uJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ2hpc3RvcnknLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGdldEdsb2JhbE9iamVjdCwgbG9nZ2VyIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5pbXBvcnQgeyBzdGFydElkbGVUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2h1YmV4dGVuc2lvbnMnO1xuaW1wb3J0IHsgREVGQVVMVF9JRExFX1RJTUVPVVQgfSBmcm9tICcuLi9pZGxldHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgU3BhblN0YXR1cyB9IGZyb20gJy4uL3NwYW5zdGF0dXMnO1xuaW1wb3J0IHsgZXh0cmFjdFRyYWNlcGFyZW50RGF0YSwgc2VjVG9NcyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlZ2lzdGVyQmFja2dyb3VuZFRhYkRldGVjdGlvbiB9IGZyb20gJy4vYmFja2dyb3VuZHRhYic7XG5pbXBvcnQgeyBNZXRyaWNzSW5zdHJ1bWVudGF0aW9uIH0gZnJvbSAnLi9tZXRyaWNzJztcbmltcG9ydCB7IGRlZmF1bHRSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uT3B0aW9ucywgaW5zdHJ1bWVudE91dGdvaW5nUmVxdWVzdHMsIH0gZnJvbSAnLi9yZXF1ZXN0JztcbmltcG9ydCB7IGluc3RydW1lbnRSb3V0aW5nV2l0aERlZmF1bHRzIH0gZnJvbSAnLi9yb3V0ZXInO1xuZXhwb3J0IHZhciBERUZBVUxUX01BWF9UUkFOU0FDVElPTl9EVVJBVElPTl9TRUNPTkRTID0gNjAwO1xudmFyIERFRkFVTFRfQlJPV1NFUl9UUkFDSU5HX09QVElPTlMgPSBfX2Fzc2lnbih7IGlkbGVUaW1lb3V0OiBERUZBVUxUX0lETEVfVElNRU9VVCwgbWFya0JhY2tncm91bmRUcmFuc2FjdGlvbnM6IHRydWUsIG1heFRyYW5zYWN0aW9uRHVyYXRpb246IERFRkFVTFRfTUFYX1RSQU5TQUNUSU9OX0RVUkFUSU9OX1NFQ09ORFMsIHJvdXRpbmdJbnN0cnVtZW50YXRpb246IGluc3RydW1lbnRSb3V0aW5nV2l0aERlZmF1bHRzLCBzdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZTogdHJ1ZSwgc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQ6IHRydWUgfSwgZGVmYXVsdFJlcXVlc3RJbnN0cnVtZW50YXRpb25PcHRpb25zKTtcbi8qKlxuICogVGhlIEJyb3dzZXIgVHJhY2luZyBpbnRlZ3JhdGlvbiBhdXRvbWF0aWNhbGx5IGluc3RydW1lbnRzIGJyb3dzZXIgcGFnZWxvYWQvbmF2aWdhdGlvblxuICogYWN0aW9ucyBhcyB0cmFuc2FjdGlvbnMsIGFuZCBjYXB0dXJlcyByZXF1ZXN0cywgbWV0cmljcyBhbmQgZXJyb3JzIGFzIHNwYW5zLlxuICpcbiAqIFRoZSBpbnRlZ3JhdGlvbiBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGEgdmFyaWV0eSBvZiBvcHRpb25zLCBhbmQgY2FuIGJlIGV4dGVuZGVkIHRvIHVzZVxuICogYW55IHJvdXRpbmcgbGlicmFyeS4gVGhpcyBpbnRlZ3JhdGlvbiB1c2VzIHtAc2VlIElkbGVUcmFuc2FjdGlvbn0gdG8gY3JlYXRlIHRyYW5zYWN0aW9ucy5cbiAqL1xudmFyIEJyb3dzZXJUcmFjaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJUcmFjaW5nKF9vcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW5oZXJpdERvY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gQnJvd3NlclRyYWNpbmcuaWQ7XG4gICAgICAgIHRoaXMuX21ldHJpY3MgPSBuZXcgTWV0cmljc0luc3RydW1lbnRhdGlvbigpO1xuICAgICAgICB0aGlzLl9lbWl0T3B0aW9uc1dhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRyYWNpbmdPcmlnaW5zID0gZGVmYXVsdFJlcXVlc3RJbnN0cnVtZW50YXRpb25PcHRpb25zLnRyYWNpbmdPcmlnaW5zO1xuICAgICAgICAvLyBOT1RFOiBMb2dnZXIgZG9lc24ndCB3b3JrIGluIGNvbnN0cnVjdG9ycywgYXMgaXQncyBpbml0aWFsaXplZCBhZnRlciBpbnRlZ3JhdGlvbnMgaW5zdGFuY2VzXG4gICAgICAgIGlmIChfb3B0aW9ucyAmJlxuICAgICAgICAgICAgX29wdGlvbnMudHJhY2luZ09yaWdpbnMgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoX29wdGlvbnMudHJhY2luZ09yaWdpbnMpICYmXG4gICAgICAgICAgICBfb3B0aW9ucy50cmFjaW5nT3JpZ2lucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRyYWNpbmdPcmlnaW5zID0gX29wdGlvbnMudHJhY2luZ09yaWdpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0T3B0aW9uc1dhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX0JST1dTRVJfVFJBQ0lOR19PUFRJT05TKSwgX29wdGlvbnMpLCB7IHRyYWNpbmdPcmlnaW5zOiB0cmFjaW5nT3JpZ2lucyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBCcm93c2VyVHJhY2luZy5wcm90b3R5cGUuc2V0dXBPbmNlID0gZnVuY3Rpb24gKF8sIGdldEN1cnJlbnRIdWIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZ2V0Q3VycmVudEh1YiA9IGdldEN1cnJlbnRIdWI7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0T3B0aW9uc1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdbVHJhY2luZ10gWW91IG5lZWQgdG8gZGVmaW5lIGB0cmFjaW5nT3JpZ2luc2AgaW4gdGhlIG9wdGlvbnMuIFNldCBhbiBhcnJheSBvZiB1cmxzIG9yIHBhdHRlcm5zIHRvIHRyYWNlLicpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJbVHJhY2luZ10gV2UgYWRkZWQgYSByZWFzb25hYmxlIGRlZmF1bHQgZm9yIHlvdTogXCIgKyBkZWZhdWx0UmVxdWVzdEluc3RydW1lbnRhdGlvbk9wdGlvbnMudHJhY2luZ09yaWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBpbnN0cnVtZW50Um91dGluZyA9IF9hLnJvdXRpbmdJbnN0cnVtZW50YXRpb24sIHN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlID0gX2Euc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2UsIHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkID0gX2Euc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQsIG1hcmtCYWNrZ3JvdW5kVHJhbnNhY3Rpb25zID0gX2EubWFya0JhY2tncm91bmRUcmFuc2FjdGlvbnMsIHRyYWNlRmV0Y2ggPSBfYS50cmFjZUZldGNoLCB0cmFjZVhIUiA9IF9hLnRyYWNlWEhSLCB0cmFjaW5nT3JpZ2lucyA9IF9hLnRyYWNpbmdPcmlnaW5zLCBzaG91bGRDcmVhdGVTcGFuRm9yUmVxdWVzdCA9IF9hLnNob3VsZENyZWF0ZVNwYW5Gb3JSZXF1ZXN0O1xuICAgICAgICBpbnN0cnVtZW50Um91dGluZyhmdW5jdGlvbiAoY29udGV4dCkgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZVJvdXRlVHJhbnNhY3Rpb24oY29udGV4dCk7IH0sIHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkLCBzdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZSk7XG4gICAgICAgIGlmIChtYXJrQmFja2dyb3VuZFRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgcmVnaXN0ZXJCYWNrZ3JvdW5kVGFiRGV0ZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdHJ1bWVudE91dGdvaW5nUmVxdWVzdHMoeyB0cmFjZUZldGNoOiB0cmFjZUZldGNoLCB0cmFjZVhIUjogdHJhY2VYSFIsIHRyYWNpbmdPcmlnaW5zOiB0cmFjaW5nT3JpZ2lucywgc2hvdWxkQ3JlYXRlU3BhbkZvclJlcXVlc3Q6IHNob3VsZENyZWF0ZVNwYW5Gb3JSZXF1ZXN0IH0pO1xuICAgIH07XG4gICAgLyoqIENyZWF0ZSByb3V0aW5nIGlkbGUgdHJhbnNhY3Rpb24uICovXG4gICAgQnJvd3NlclRyYWNpbmcucHJvdG90eXBlLl9jcmVhdGVSb3V0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRDdXJyZW50SHViKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIltUcmFjaW5nXSBEaWQgbm90IGNyZWF0ZSBcIiArIGNvbnRleHQub3AgKyBcIiB0cmFuc2FjdGlvbiBiZWNhdXNlIF9nZXRDdXJyZW50SHViIGlzIGludmFsaWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgYmVmb3JlTmF2aWdhdGUgPSBfYS5iZWZvcmVOYXZpZ2F0ZSwgaWRsZVRpbWVvdXQgPSBfYS5pZGxlVGltZW91dCwgbWF4VHJhbnNhY3Rpb25EdXJhdGlvbiA9IF9hLm1heFRyYW5zYWN0aW9uRHVyYXRpb247XG4gICAgICAgIHZhciBwYXJlbnRDb250ZXh0RnJvbUhlYWRlciA9IGNvbnRleHQub3AgPT09ICdwYWdlbG9hZCcgPyBnZXRIZWFkZXJDb250ZXh0KCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBleHBhbmRlZENvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dCksIHBhcmVudENvbnRleHRGcm9tSGVhZGVyKSwgeyB0cmltRW5kOiB0cnVlIH0pO1xuICAgICAgICB2YXIgbW9kaWZpZWRDb250ZXh0ID0gdHlwZW9mIGJlZm9yZU5hdmlnYXRlID09PSAnZnVuY3Rpb24nID8gYmVmb3JlTmF2aWdhdGUoZXhwYW5kZWRDb250ZXh0KSA6IGV4cGFuZGVkQ29udGV4dDtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMsIGJlZm9yZU5hdmlnYXRlIGNhbiByZXR1cm4gdW5kZWZpbmVkIHRvIFwiZHJvcFwiIHRoZSB0cmFuc2FjdGlvbiAocHJldmVudCBpdFxuICAgICAgICAvLyBmcm9tIGJlaW5nIHNlbnQgdG8gU2VudHJ5KS5cbiAgICAgICAgdmFyIGZpbmFsQ29udGV4dCA9IG1vZGlmaWVkQ29udGV4dCA9PT0gdW5kZWZpbmVkID8gX19hc3NpZ24oX19hc3NpZ24oe30sIGV4cGFuZGVkQ29udGV4dCksIHsgc2FtcGxlZDogZmFsc2UgfSkgOiBtb2RpZmllZENvbnRleHQ7XG4gICAgICAgIGlmIChmaW5hbENvbnRleHQuc2FtcGxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJbVHJhY2luZ10gV2lsbCBub3Qgc2VuZCBcIiArIGZpbmFsQ29udGV4dC5vcCArIFwiIHRyYW5zYWN0aW9uIGJlY2F1c2Ugb2YgYmVmb3JlTmF2aWdhdGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5sb2coXCJbVHJhY2luZ10gU3RhcnRpbmcgXCIgKyBmaW5hbENvbnRleHQub3AgKyBcIiB0cmFuc2FjdGlvbiBvbiBzY29wZVwiKTtcbiAgICAgICAgdmFyIGh1YiA9IHRoaXMuX2dldEN1cnJlbnRIdWIoKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0R2xvYmFsT2JqZWN0KCkubG9jYXRpb247XG4gICAgICAgIHZhciBpZGxlVHJhbnNhY3Rpb24gPSBzdGFydElkbGVUcmFuc2FjdGlvbihodWIsIGZpbmFsQ29udGV4dCwgaWRsZVRpbWVvdXQsIHRydWUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICBpZGxlVHJhbnNhY3Rpb24ucmVnaXN0ZXJCZWZvcmVGaW5pc2hDYWxsYmFjayhmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGVuZFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgX3RoaXMuX21ldHJpY3MuYWRkUGVyZm9ybWFuY2VFbnRyaWVzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGFkanVzdFRyYW5zYWN0aW9uRHVyYXRpb24oc2VjVG9NcyhtYXhUcmFuc2FjdGlvbkR1cmF0aW9uKSwgdHJhbnNhY3Rpb24sIGVuZFRpbWVzdGFtcCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWRsZVRyYW5zYWN0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBCcm93c2VyVHJhY2luZy5pZCA9ICdCcm93c2VyVHJhY2luZyc7XG4gICAgcmV0dXJuIEJyb3dzZXJUcmFjaW5nO1xufSgpKTtcbmV4cG9ydCB7IEJyb3dzZXJUcmFjaW5nIH07XG4vKipcbiAqIEdldHMgdHJhbnNhY3Rpb24gY29udGV4dCBmcm9tIGEgc2VudHJ5LXRyYWNlIG1ldGEuXG4gKlxuICogQHJldHVybnMgVHJhbnNhY3Rpb24gY29udGV4dCBkYXRhIGZyb20gdGhlIGhlYWRlciBvciB1bmRlZmluZWQgaWYgdGhlcmUncyBubyBoZWFkZXIgb3IgdGhlIGhlYWRlciBpcyBtYWxmb3JtZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckNvbnRleHQoKSB7XG4gICAgdmFyIGhlYWRlciA9IGdldE1ldGFDb250ZW50KCdzZW50cnktdHJhY2UnKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0VHJhY2VwYXJlbnREYXRhKGhlYWRlcik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKiogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBtZXRhIHRhZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFDb250ZW50KG1ldGFOYW1lKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT1cIiArIG1ldGFOYW1lICsgXCJdXCIpO1xuICAgIHJldHVybiBlbCA/IGVsLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbn1cbi8qKiBBZGp1c3RzIHRyYW5zYWN0aW9uIHZhbHVlIGJhc2VkIG9uIG1heCB0cmFuc2FjdGlvbiBkdXJhdGlvbiAqL1xuZnVuY3Rpb24gYWRqdXN0VHJhbnNhY3Rpb25EdXJhdGlvbihtYXhEdXJhdGlvbiwgdHJhbnNhY3Rpb24sIGVuZFRpbWVzdGFtcCkge1xuICAgIHZhciBkaWZmID0gZW5kVGltZXN0YW1wIC0gdHJhbnNhY3Rpb24uc3RhcnRUaW1lc3RhbXA7XG4gICAgdmFyIGlzT3V0ZGF0ZWRUcmFuc2FjdGlvbiA9IGVuZFRpbWVzdGFtcCAmJiAoZGlmZiA+IG1heER1cmF0aW9uIHx8IGRpZmYgPCAwKTtcbiAgICBpZiAoaXNPdXRkYXRlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNldFN0YXR1cyhTcGFuU3RhdHVzLkRlYWRsaW5lRXhjZWVkZWQpO1xuICAgICAgICB0cmFuc2FjdGlvbi5zZXRUYWcoJ21heFRyYW5zYWN0aW9uRHVyYXRpb25FeGNlZWRlZCcsICd0cnVlJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3NlcnRyYWNpbmcuanMubWFwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///146\n")},21:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return captureException; });\n/* unused harmony export captureMessage */\n/* unused harmony export captureEvent */\n/* unused harmony export configureScope */\n/* unused harmony export addBreadcrumb */\n/* unused harmony export setContext */\n/* unused harmony export setExtras */\n/* unused harmony export setTags */\n/* unused harmony export setExtra */\n/* unused harmony export setTag */\n/* unused harmony export setUser */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return withScope; });\n/* unused harmony export _callOnClient */\n/* unused harmony export startTransaction */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n\n\n/**\n * This calls a function on the current hub.\n * @param method function to call on hub.\n * @param args to pass to function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction callOnHub(method) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var hub = Object(_sentry_hub__WEBPACK_IMPORTED_MODULE_1__[/* getCurrentHub */ \"b\"])();\n    if (hub && hub[method]) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return hub[method].apply(hub, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \"g\"])(args));\n    }\n    throw new Error(\"No hub defined or \" + method + \" was not found on the hub, please open a bug report.\");\n}\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @returns The generated eventId.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nfunction captureException(exception, captureContext) {\n    var syntheticException;\n    try {\n        throw new Error('Sentry syntheticException');\n    }\n    catch (exception) {\n        syntheticException = exception;\n    }\n    return callOnHub('captureException', exception, {\n        captureContext: captureContext,\n        originalException: exception,\n        syntheticException: syntheticException,\n    });\n}\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param level Define the level of the message.\n * @returns The generated eventId.\n */\nfunction captureMessage(message, captureContext) {\n    var syntheticException;\n    try {\n        throw new Error(message);\n    }\n    catch (exception) {\n        syntheticException = exception;\n    }\n    // This is necessary to provide explicit scopes upgrade, without changing the original\n    // arity of the `captureMessage(message, level)` method.\n    var level = typeof captureContext === 'string' ? captureContext : undefined;\n    var context = typeof captureContext !== 'string' ? { captureContext: captureContext } : undefined;\n    return callOnHub('captureMessage', message, level, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \"a\"])({ originalException: message, syntheticException: syntheticException }, context));\n}\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @returns The generated eventId.\n */\nfunction captureEvent(event) {\n    return callOnHub('captureEvent', event);\n}\n/**\n * Callback to set context information onto the scope.\n * @param callback Callback function that receives Scope.\n */\nfunction configureScope(callback) {\n    callOnHub('configureScope', callback);\n}\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nfunction addBreadcrumb(breadcrumb) {\n    callOnHub('addBreadcrumb', breadcrumb);\n}\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setContext(name, context) {\n    callOnHub('setContext', name, context);\n}\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nfunction setExtras(extras) {\n    callOnHub('setExtras', extras);\n}\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nfunction setTags(tags) {\n    callOnHub('setTags', tags);\n}\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nfunction setExtra(key, extra) {\n    callOnHub('setExtra', key, extra);\n}\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nfunction setTag(key, value) {\n    callOnHub('setTag', key, value);\n}\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nfunction setUser(user) {\n    callOnHub('setUser', user);\n}\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback that will be enclosed into push/popScope.\n */\nfunction withScope(callback) {\n    callOnHub('withScope', callback);\n}\n/**\n * Calls a function on the latest client. Use this with caution, it's meant as\n * in \"internal\" helper so we don't need to expose every possible function in\n * the shim. It is not guaranteed that the client actually implements the\n * function.\n *\n * @param method The method to call on the client/client.\n * @param args Arguments to pass to the client/fontend.\n * @hidden\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _callOnClient(method) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    callOnHub.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ \"g\"])(['_invokeClient', method], args));\n}\n/**\n * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.\n *\n * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a\n * new child span within the transaction or any span, call the respective `.startChild()` method.\n *\n * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.\n *\n * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its\n * finished child spans will be sent to Sentry.\n *\n * @param context Properties of the new `Transaction`.\n * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent\n * default values). See {@link Options.tracesSampler}.\n *\n * @returns The transaction which was just started\n */\nfunction startTransaction(context, customSamplingContext) {\n    return callOnHub('startTransaction', Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \"a\"])({}, context), customSamplingContext);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS9taW5pbWFsL2VzbS9pbmRleC5qcz84MmRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXNzaWduLCBfX3JlYWQsIF9fc3ByZWFkIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBnZXRDdXJyZW50SHViIH0gZnJvbSAnQHNlbnRyeS9odWInO1xuLyoqXG4gKiBUaGlzIGNhbGxzIGEgZnVuY3Rpb24gb24gdGhlIGN1cnJlbnQgaHViLlxuICogQHBhcmFtIG1ldGhvZCBmdW5jdGlvbiB0byBjYWxsIG9uIGh1Yi5cbiAqIEBwYXJhbSBhcmdzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBjYWxsT25IdWIobWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgaHViID0gZ2V0Q3VycmVudEh1YigpO1xuICAgIGlmIChodWIgJiYgaHViW21ldGhvZF0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGh1YlttZXRob2RdLmFwcGx5KGh1YiwgX19zcHJlYWQoYXJncykpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBodWIgZGVmaW5lZCBvciBcIiArIG1ldGhvZCArIFwiIHdhcyBub3QgZm91bmQgb24gdGhlIGh1YiwgcGxlYXNlIG9wZW4gYSBidWcgcmVwb3J0LlwiKTtcbn1cbi8qKlxuICogQ2FwdHVyZXMgYW4gZXhjZXB0aW9uIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIGV4Y2VwdGlvbiBBbiBleGNlcHRpb24tbGlrZSBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGV2ZW50SWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZUV4Y2VwdGlvbihleGNlcHRpb24sIGNhcHR1cmVDb250ZXh0KSB7XG4gICAgdmFyIHN5bnRoZXRpY0V4Y2VwdGlvbjtcbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbnRyeSBzeW50aGV0aWNFeGNlcHRpb24nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb24gPSBleGNlcHRpb247XG4gICAgfVxuICAgIHJldHVybiBjYWxsT25IdWIoJ2NhcHR1cmVFeGNlcHRpb24nLCBleGNlcHRpb24sIHtcbiAgICAgICAgY2FwdHVyZUNvbnRleHQ6IGNhcHR1cmVDb250ZXh0LFxuICAgICAgICBvcmlnaW5hbEV4Y2VwdGlvbjogZXhjZXB0aW9uLFxuICAgICAgICBzeW50aGV0aWNFeGNlcHRpb246IHN5bnRoZXRpY0V4Y2VwdGlvbixcbiAgICB9KTtcbn1cbi8qKlxuICogQ2FwdHVyZXMgYSBtZXNzYWdlIGV2ZW50IGFuZCBzZW5kcyBpdCB0byBTZW50cnkuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byBTZW50cnkuXG4gKiBAcGFyYW0gbGV2ZWwgRGVmaW5lIHRoZSBsZXZlbCBvZiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgZXZlbnRJZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVNZXNzYWdlKG1lc3NhZ2UsIGNhcHR1cmVDb250ZXh0KSB7XG4gICAgdmFyIHN5bnRoZXRpY0V4Y2VwdGlvbjtcbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgc3ludGhldGljRXhjZXB0aW9uID0gZXhjZXB0aW9uO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBwcm92aWRlIGV4cGxpY2l0IHNjb3BlcyB1cGdyYWRlLCB3aXRob3V0IGNoYW5naW5nIHRoZSBvcmlnaW5hbFxuICAgIC8vIGFyaXR5IG9mIHRoZSBgY2FwdHVyZU1lc3NhZ2UobWVzc2FnZSwgbGV2ZWwpYCBtZXRob2QuXG4gICAgdmFyIGxldmVsID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ID09PSAnc3RyaW5nJyA/IGNhcHR1cmVDb250ZXh0IDogdW5kZWZpbmVkO1xuICAgIHZhciBjb250ZXh0ID0gdHlwZW9mIGNhcHR1cmVDb250ZXh0ICE9PSAnc3RyaW5nJyA/IHsgY2FwdHVyZUNvbnRleHQ6IGNhcHR1cmVDb250ZXh0IH0gOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNhbGxPbkh1YignY2FwdHVyZU1lc3NhZ2UnLCBtZXNzYWdlLCBsZXZlbCwgX19hc3NpZ24oeyBvcmlnaW5hbEV4Y2VwdGlvbjogbWVzc2FnZSwgc3ludGhldGljRXhjZXB0aW9uOiBzeW50aGV0aWNFeGNlcHRpb24gfSwgY29udGV4dCkpO1xufVxuLyoqXG4gKiBDYXB0dXJlcyBhIG1hbnVhbGx5IGNyZWF0ZWQgZXZlbnQgYW5kIHNlbmRzIGl0IHRvIFNlbnRyeS5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gU2VudHJ5LlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBldmVudElkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZUV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGNhbGxPbkh1YignY2FwdHVyZUV2ZW50JywgZXZlbnQpO1xufVxuLyoqXG4gKiBDYWxsYmFjayB0byBzZXQgY29udGV4dCBpbmZvcm1hdGlvbiBvbnRvIHRoZSBzY29wZS5cbiAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIFNjb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjYWxsT25IdWIoJ2NvbmZpZ3VyZVNjb3BlJywgY2FsbGJhY2spO1xufVxuLyoqXG4gKiBSZWNvcmRzIGEgbmV3IGJyZWFkY3J1bWIgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byBmdXR1cmUgZXZlbnRzLlxuICpcbiAqIEJyZWFkY3J1bWJzIHdpbGwgYmUgYWRkZWQgdG8gc3Vic2VxdWVudCBldmVudHMgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQgb25cbiAqIHVzZXIncyBhY3Rpb25zIHByaW9yIHRvIGFuIGVycm9yIG9yIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBicmVhZGNydW1iIFRoZSBicmVhZGNydW1iIHRvIHJlY29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEJyZWFkY3J1bWIoYnJlYWRjcnVtYikge1xuICAgIGNhbGxPbkh1YignYWRkQnJlYWRjcnVtYicsIGJyZWFkY3J1bWIpO1xufVxuLyoqXG4gKiBTZXRzIGNvbnRleHQgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICogQHBhcmFtIG5hbWUgb2YgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSBjb250ZXh0IEFueSBraW5kIG9mIGRhdGEuIFRoaXMgZGF0YSB3aWxsIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChuYW1lLCBjb250ZXh0KSB7XG4gICAgY2FsbE9uSHViKCdzZXRDb250ZXh0JywgbmFtZSwgY29udGV4dCk7XG59XG4vKipcbiAqIFNldCBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIG1lcmdlZCBzZW50IGFzIGV4dHJhIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gZXh0cmFzIEV4dHJhcyBvYmplY3QgdG8gbWVyZ2UgaW50byBjdXJyZW50IGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYXMoZXh0cmFzKSB7XG4gICAgY2FsbE9uSHViKCdzZXRFeHRyYXMnLCBleHRyYXMpO1xufVxuLyoqXG4gKiBTZXQgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBtZXJnZWQgc2VudCBhcyB0YWdzIGRhdGEgd2l0aCB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gdGFncyBUYWdzIGNvbnRleHQgb2JqZWN0IHRvIG1lcmdlIGludG8gY3VycmVudCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VGFncyh0YWdzKSB7XG4gICAgY2FsbE9uSHViKCdzZXRUYWdzJywgdGFncyk7XG59XG4vKipcbiAqIFNldCBrZXk6dmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgYXMgZXh0cmEgZGF0YSB3aXRoIHRoZSBldmVudC5cbiAqIEBwYXJhbSBrZXkgU3RyaW5nIG9mIGV4dHJhXG4gKiBAcGFyYW0gZXh0cmEgQW55IGtpbmQgb2YgZGF0YS4gVGhpcyBkYXRhIHdpbGwgYmUgbm9ybWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEV4dHJhKGtleSwgZXh0cmEpIHtcbiAgICBjYWxsT25IdWIoJ3NldEV4dHJhJywga2V5LCBleHRyYSk7XG59XG4vKipcbiAqIFNldCBrZXk6dmFsdWUgdGhhdCB3aWxsIGJlIHNlbnQgYXMgdGFncyBkYXRhIHdpdGggdGhlIGV2ZW50LlxuICpcbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gdW5zZXQgYSB0YWcsIGJ5IHBhc3NpbmcgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGtleSBTdHJpbmcga2V5IG9mIHRhZ1xuICogQHBhcmFtIHZhbHVlIFZhbHVlIG9mIHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0VGFnKGtleSwgdmFsdWUpIHtcbiAgICBjYWxsT25IdWIoJ3NldFRhZycsIGtleSwgdmFsdWUpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHVzZXIgY29udGV4dCBpbmZvcm1hdGlvbiBmb3IgZnV0dXJlIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0gdXNlciBVc2VyIGNvbnRleHQgb2JqZWN0IHRvIGJlIHNldCBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBQYXNzIGBudWxsYCB0byB1bnNldCB0aGUgdXNlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFVzZXIodXNlcikge1xuICAgIGNhbGxPbkh1Yignc2V0VXNlcicsIHVzZXIpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNjb3BlIHdpdGggYW5kIGV4ZWN1dGVzIHRoZSBnaXZlbiBvcGVyYXRpb24gd2l0aGluLlxuICogVGhlIHNjb3BlIGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBvbmNlIHRoZSBvcGVyYXRpb25cbiAqIGZpbmlzaGVzIG9yIHRocm93cy5cbiAqXG4gKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yOlxuICpcbiAqICAgICBwdXNoU2NvcGUoKTtcbiAqICAgICBjYWxsYmFjaygpO1xuICogICAgIHBvcFNjb3BlKCk7XG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBlbmNsb3NlZCBpbnRvIHB1c2gvcG9wU2NvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjYWxsT25IdWIoJ3dpdGhTY29wZScsIGNhbGxiYWNrKTtcbn1cbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBvbiB0aGUgbGF0ZXN0IGNsaWVudC4gVXNlIHRoaXMgd2l0aCBjYXV0aW9uLCBpdCdzIG1lYW50IGFzXG4gKiBpbiBcImludGVybmFsXCIgaGVscGVyIHNvIHdlIGRvbid0IG5lZWQgdG8gZXhwb3NlIGV2ZXJ5IHBvc3NpYmxlIGZ1bmN0aW9uIGluXG4gKiB0aGUgc2hpbS4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCB0aGUgY2xpZW50IGFjdHVhbGx5IGltcGxlbWVudHMgdGhlXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbCBvbiB0aGUgY2xpZW50L2NsaWVudC5cbiAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjbGllbnQvZm9udGVuZC5cbiAqIEBoaWRkZW5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfY2FsbE9uQ2xpZW50KG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY2FsbE9uSHViLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoWydfaW52b2tlQ2xpZW50JywgbWV0aG9kXSwgYXJncykpO1xufVxuLyoqXG4gKiBTdGFydHMgYSBuZXcgYFRyYW5zYWN0aW9uYCBhbmQgcmV0dXJucyBpdC4gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgdG8gbWFudWFsIHRyYWNpbmcgaW5zdHJ1bWVudGF0aW9uLlxuICpcbiAqIEEgdHJlZSBzdHJ1Y3R1cmUgY2FuIGJlIGJ1aWx0IGJ5IGFkZGluZyBjaGlsZCBzcGFucyB0byB0aGUgdHJhbnNhY3Rpb24sIGFuZCBjaGlsZCBzcGFucyB0byBvdGhlciBzcGFucy4gVG8gc3RhcnQgYVxuICogbmV3IGNoaWxkIHNwYW4gd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvciBhbnkgc3BhbiwgY2FsbCB0aGUgcmVzcGVjdGl2ZSBgLnN0YXJ0Q2hpbGQoKWAgbWV0aG9kLlxuICpcbiAqIEV2ZXJ5IGNoaWxkIHNwYW4gbXVzdCBiZSBmaW5pc2hlZCBiZWZvcmUgdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkLCBvdGhlcndpc2UgdGhlIHVuZmluaXNoZWQgc3BhbnMgYXJlIGRpc2NhcmRlZC5cbiAqXG4gKiBUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBmaW5pc2hlZCB3aXRoIGEgY2FsbCB0byBpdHMgYC5maW5pc2goKWAgbWV0aG9kLCBhdCB3aGljaCBwb2ludCB0aGUgdHJhbnNhY3Rpb24gd2l0aCBhbGwgaXRzXG4gKiBmaW5pc2hlZCBjaGlsZCBzcGFucyB3aWxsIGJlIHNlbnQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IFByb3BlcnRpZXMgb2YgdGhlIG5ldyBgVHJhbnNhY3Rpb25gLlxuICogQHBhcmFtIGN1c3RvbVNhbXBsaW5nQ29udGV4dCBJbmZvcm1hdGlvbiBnaXZlbiB0byB0aGUgdHJhbnNhY3Rpb24gc2FtcGxpbmcgZnVuY3Rpb24gKGFsb25nIHdpdGggY29udGV4dC1kZXBlbmRlbnRcbiAqIGRlZmF1bHQgdmFsdWVzKS4gU2VlIHtAbGluayBPcHRpb25zLnRyYWNlc1NhbXBsZXJ9LlxuICpcbiAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiB3aGljaCB3YXMganVzdCBzdGFydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFRyYW5zYWN0aW9uKGNvbnRleHQsIGN1c3RvbVNhbXBsaW5nQ29udGV4dCkge1xuICAgIHJldHVybiBjYWxsT25IdWIoJ3N0YXJ0VHJhbnNhY3Rpb24nLCBfX2Fzc2lnbih7fSwgY29udGV4dCksIGN1c3RvbVNhbXBsaW5nQ29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n")},64:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export DEFAULT_TRACING_ORIGINS */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultRequestInstrumentationOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return instrumentOutgoingRequests; });\n/* unused harmony export fetchCallback */\n/* unused harmony export xhrCallback */\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _sentry_hub__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);\n/* harmony import */ var _sentry_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);\n\n\n\n\nvar DEFAULT_TRACING_ORIGINS = [\'localhost\', /^\\//];\nvar defaultRequestInstrumentationOptions = {\n    traceFetch: true,\n    traceXHR: true,\n    tracingOrigins: DEFAULT_TRACING_ORIGINS,\n};\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;\n    // We should cache url -> decision so that we don\'t have to compute\n    // regexp everytime we create a request.\n    var urlMap = {};\n    var defaultShouldCreateSpan = function (url) {\n        if (urlMap[url]) {\n            return urlMap[url];\n        }\n        var origins = tracingOrigins;\n        urlMap[url] =\n            origins.some(function (origin) { return Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_2__[/* isMatchingPattern */ "a"])(url, origin); }) &&\n                !Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_2__[/* isMatchingPattern */ "a"])(url, \'sentry_key\');\n        return urlMap[url];\n    };\n    // We want that our users don\'t have to re-implement shouldCreateSpanForRequest themselves\n    // That\'s why we filter out already unwanted Spans from tracingOrigins\n    var shouldCreateSpan = defaultShouldCreateSpan;\n    if (typeof shouldCreateSpanForRequest === \'function\') {\n        shouldCreateSpan = function (url) {\n            return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);\n        };\n    }\n    var spans = {};\n    if (traceFetch) {\n        Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_3__[/* addInstrumentationHandler */ "a"])({\n            callback: function (handlerData) {\n                fetchCallback(handlerData, shouldCreateSpan, spans);\n            },\n            type: \'fetch\',\n        });\n    }\n    if (traceXHR) {\n        Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_3__[/* addInstrumentationHandler */ "a"])({\n            callback: function (handlerData) {\n                xhrCallback(handlerData, shouldCreateSpan, spans);\n            },\n            type: \'xhr\',\n        });\n    }\n}\n/**\n * Create and track fetch request spans\n */\nfunction fetchCallback(handlerData, shouldCreateSpan, spans) {\n    var _a;\n    var currentClientOptions = (_a = Object(_sentry_hub__WEBPACK_IMPORTED_MODULE_1__[/* getCurrentHub */ "b"])()\n        .getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();\n    if (!(currentClientOptions && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* hasTracingEnabled */ "c"])(currentClientOptions)) ||\n        !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n        return;\n    }\n    if (handlerData.endTimestamp && handlerData.fetchData.__span) {\n        var span = spans[handlerData.fetchData.__span];\n        if (span) {\n            var response = handlerData.response;\n            if (response) {\n                // TODO (kmclb) remove this once types PR goes through\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                span.setHttpStatus(response.status);\n            }\n            span.finish();\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete spans[handlerData.fetchData.__span];\n        }\n        return;\n    }\n    var activeTransaction = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* getActiveTransaction */ "b"])();\n    if (activeTransaction) {\n        var span = activeTransaction.startChild({\n            data: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, handlerData.fetchData), { type: \'fetch\' }),\n            description: handlerData.fetchData.method + " " + handlerData.fetchData.url,\n            op: \'http\',\n        });\n        handlerData.fetchData.__span = span.spanId;\n        spans[span.spanId] = span;\n        var request = (handlerData.args[0] = handlerData.args[0]);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var options = (handlerData.args[1] = handlerData.args[1] || {});\n        var headers = options.headers;\n        if (Object(_sentry_utils__WEBPACK_IMPORTED_MODULE_4__[/* isInstanceOf */ "g"])(request, Request)) {\n            headers = request.headers;\n        }\n        if (headers) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (typeof headers.append === \'function\') {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                headers.append(\'sentry-trace\', span.toTraceparent());\n            }\n            else if (Array.isArray(headers)) {\n                headers = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spread */ "g"])(headers, [[\'sentry-trace\', span.toTraceparent()]]);\n            }\n            else {\n                headers = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, headers), { \'sentry-trace\': span.toTraceparent() });\n            }\n        }\n        else {\n            headers = { \'sentry-trace\': span.toTraceparent() };\n        }\n        options.headers = headers;\n    }\n}\n/**\n * Create and track xhr request spans\n */\nfunction xhrCallback(handlerData, shouldCreateSpan, spans) {\n    var _a;\n    var currentClientOptions = (_a = Object(_sentry_hub__WEBPACK_IMPORTED_MODULE_1__[/* getCurrentHub */ "b"])()\n        .getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();\n    if (!(currentClientOptions && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* hasTracingEnabled */ "c"])(currentClientOptions)) ||\n        !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url)) ||\n        handlerData.xhr.__sentry_own_request__) {\n        return;\n    }\n    var xhr = handlerData.xhr.__sentry_xhr__;\n    // check first if the request has finished and is tracked by an existing span which should now end\n    if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {\n        var span = spans[handlerData.xhr.__sentry_xhr_span_id__];\n        if (span) {\n            span.setHttpStatus(xhr.status_code);\n            span.finish();\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete spans[handlerData.xhr.__sentry_xhr_span_id__];\n        }\n        return;\n    }\n    // if not, create a new span to track it\n    var activeTransaction = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[/* getActiveTransaction */ "b"])();\n    if (activeTransaction) {\n        var span = activeTransaction.startChild({\n            data: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, xhr.data), { type: \'xhr\', method: xhr.method, url: xhr.url }),\n            description: xhr.method + " " + xhr.url,\n            op: \'http\',\n        });\n        handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n        spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n        if (handlerData.xhr.setRequestHeader) {\n            try {\n                handlerData.xhr.setRequestHeader(\'sentry-trace\', span.toTraceparent());\n            }\n            catch (_) {\n                // Error: InvalidStateError: Failed to execute \'setRequestHeader\' on \'XMLHttpRequest\': The object\'s state must be OPENED.\n            }\n        }\n    }\n}\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS90cmFjaW5nL2VzbS9icm93c2VyL3JlcXVlc3QuanM/NzJiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2Fzc2lnbiwgX19yZWFkLCBfX3NwcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudEh1YiB9IGZyb20gJ0BzZW50cnkvaHViJztcbmltcG9ydCB7IGFkZEluc3RydW1lbnRhdGlvbkhhbmRsZXIsIGlzSW5zdGFuY2VPZiwgaXNNYXRjaGluZ1BhdHRlcm4gfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbmltcG9ydCB7IGdldEFjdGl2ZVRyYW5zYWN0aW9uLCBoYXNUcmFjaW5nRW5hYmxlZCB9IGZyb20gJy4uL3V0aWxzJztcbmV4cG9ydCB2YXIgREVGQVVMVF9UUkFDSU5HX09SSUdJTlMgPSBbJ2xvY2FsaG9zdCcsIC9eXFwvL107XG5leHBvcnQgdmFyIGRlZmF1bHRSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uT3B0aW9ucyA9IHtcbiAgICB0cmFjZUZldGNoOiB0cnVlLFxuICAgIHRyYWNlWEhSOiB0cnVlLFxuICAgIHRyYWNpbmdPcmlnaW5zOiBERUZBVUxUX1RSQUNJTkdfT1JJR0lOUyxcbn07XG4vKiogUmVnaXN0ZXJzIHNwYW4gY3JlYXRvcnMgZm9yIHhociBhbmQgZmV0Y2ggcmVxdWVzdHMgICovXG5leHBvcnQgZnVuY3Rpb24gaW5zdHJ1bWVudE91dGdvaW5nUmVxdWVzdHMoX29wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgdmFyIF9hID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRSZXF1ZXN0SW5zdHJ1bWVudGF0aW9uT3B0aW9ucyksIF9vcHRpb25zKSwgdHJhY2VGZXRjaCA9IF9hLnRyYWNlRmV0Y2gsIHRyYWNlWEhSID0gX2EudHJhY2VYSFIsIHRyYWNpbmdPcmlnaW5zID0gX2EudHJhY2luZ09yaWdpbnMsIHNob3VsZENyZWF0ZVNwYW5Gb3JSZXF1ZXN0ID0gX2Euc2hvdWxkQ3JlYXRlU3BhbkZvclJlcXVlc3Q7XG4gICAgLy8gV2Ugc2hvdWxkIGNhY2hlIHVybCAtPiBkZWNpc2lvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gY29tcHV0ZVxuICAgIC8vIHJlZ2V4cCBldmVyeXRpbWUgd2UgY3JlYXRlIGEgcmVxdWVzdC5cbiAgICB2YXIgdXJsTWFwID0ge307XG4gICAgdmFyIGRlZmF1bHRTaG91bGRDcmVhdGVTcGFuID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICBpZiAodXJsTWFwW3VybF0pIHtcbiAgICAgICAgICAgIHJldHVybiB1cmxNYXBbdXJsXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2lucyA9IHRyYWNpbmdPcmlnaW5zO1xuICAgICAgICB1cmxNYXBbdXJsXSA9XG4gICAgICAgICAgICBvcmlnaW5zLnNvbWUoZnVuY3Rpb24gKG9yaWdpbikgeyByZXR1cm4gaXNNYXRjaGluZ1BhdHRlcm4odXJsLCBvcmlnaW4pOyB9KSAmJlxuICAgICAgICAgICAgICAgICFpc01hdGNoaW5nUGF0dGVybih1cmwsICdzZW50cnlfa2V5Jyk7XG4gICAgICAgIHJldHVybiB1cmxNYXBbdXJsXTtcbiAgICB9O1xuICAgIC8vIFdlIHdhbnQgdGhhdCBvdXIgdXNlcnMgZG9uJ3QgaGF2ZSB0byByZS1pbXBsZW1lbnQgc2hvdWxkQ3JlYXRlU3BhbkZvclJlcXVlc3QgdGhlbXNlbHZlc1xuICAgIC8vIFRoYXQncyB3aHkgd2UgZmlsdGVyIG91dCBhbHJlYWR5IHVud2FudGVkIFNwYW5zIGZyb20gdHJhY2luZ09yaWdpbnNcbiAgICB2YXIgc2hvdWxkQ3JlYXRlU3BhbiA9IGRlZmF1bHRTaG91bGRDcmVhdGVTcGFuO1xuICAgIGlmICh0eXBlb2Ygc2hvdWxkQ3JlYXRlU3BhbkZvclJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2hvdWxkQ3JlYXRlU3BhbiA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2hvdWxkQ3JlYXRlU3Bhbih1cmwpICYmIHNob3VsZENyZWF0ZVNwYW5Gb3JSZXF1ZXN0KHVybCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBzcGFucyA9IHt9O1xuICAgIGlmICh0cmFjZUZldGNoKSB7XG4gICAgICAgIGFkZEluc3RydW1lbnRhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoYW5kbGVyRGF0YSkge1xuICAgICAgICAgICAgICAgIGZldGNoQ2FsbGJhY2soaGFuZGxlckRhdGEsIHNob3VsZENyZWF0ZVNwYW4sIHNwYW5zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnZmV0Y2gnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRyYWNlWEhSKSB7XG4gICAgICAgIGFkZEluc3RydW1lbnRhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChoYW5kbGVyRGF0YSkge1xuICAgICAgICAgICAgICAgIHhockNhbGxiYWNrKGhhbmRsZXJEYXRhLCBzaG91bGRDcmVhdGVTcGFuLCBzcGFucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ3hocicsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuZCB0cmFjayBmZXRjaCByZXF1ZXN0IHNwYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaENhbGxiYWNrKGhhbmRsZXJEYXRhLCBzaG91bGRDcmVhdGVTcGFuLCBzcGFucykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgY3VycmVudENsaWVudE9wdGlvbnMgPSAoX2EgPSBnZXRDdXJyZW50SHViKClcbiAgICAgICAgLmdldENsaWVudCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpO1xuICAgIGlmICghKGN1cnJlbnRDbGllbnRPcHRpb25zICYmIGhhc1RyYWNpbmdFbmFibGVkKGN1cnJlbnRDbGllbnRPcHRpb25zKSkgfHxcbiAgICAgICAgIShoYW5kbGVyRGF0YS5mZXRjaERhdGEgJiYgc2hvdWxkQ3JlYXRlU3BhbihoYW5kbGVyRGF0YS5mZXRjaERhdGEudXJsKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaGFuZGxlckRhdGEuZW5kVGltZXN0YW1wICYmIGhhbmRsZXJEYXRhLmZldGNoRGF0YS5fX3NwYW4pIHtcbiAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1toYW5kbGVyRGF0YS5mZXRjaERhdGEuX19zcGFuXTtcbiAgICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGhhbmRsZXJEYXRhLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAoa21jbGIpIHJlbW92ZSB0aGlzIG9uY2UgdHlwZXMgUFIgZ29lcyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0SHR0cFN0YXR1cyhyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Bhbi5maW5pc2goKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzcGFuc1toYW5kbGVyRGF0YS5mZXRjaERhdGEuX19zcGFuXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHZhciBzcGFuID0gYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgICBkYXRhOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaGFuZGxlckRhdGEuZmV0Y2hEYXRhKSwgeyB0eXBlOiAnZmV0Y2gnIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGhhbmRsZXJEYXRhLmZldGNoRGF0YS5tZXRob2QgKyBcIiBcIiArIGhhbmRsZXJEYXRhLmZldGNoRGF0YS51cmwsXG4gICAgICAgICAgICBvcDogJ2h0dHAnLFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlckRhdGEuZmV0Y2hEYXRhLl9fc3BhbiA9IHNwYW4uc3BhbklkO1xuICAgICAgICBzcGFuc1tzcGFuLnNwYW5JZF0gPSBzcGFuO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IChoYW5kbGVyRGF0YS5hcmdzWzBdID0gaGFuZGxlckRhdGEuYXJnc1swXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHZhciBvcHRpb25zID0gKGhhbmRsZXJEYXRhLmFyZ3NbMV0gPSBoYW5kbGVyRGF0YS5hcmdzWzFdIHx8IHt9KTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGlmIChpc0luc3RhbmNlT2YocmVxdWVzdCwgUmVxdWVzdCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGVhZGVycy5hcHBlbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ3NlbnRyeS10cmFjZScsIHNwYW4udG9UcmFjZXBhcmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gX19zcHJlYWQoaGVhZGVycywgW1snc2VudHJ5LXRyYWNlJywgc3Bhbi50b1RyYWNlcGFyZW50KCldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGhlYWRlcnMpLCB7ICdzZW50cnktdHJhY2UnOiBzcGFuLnRvVHJhY2VwYXJlbnQoKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdzZW50cnktdHJhY2UnOiBzcGFuLnRvVHJhY2VwYXJlbnQoKSB9O1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW5kIHRyYWNrIHhociByZXF1ZXN0IHNwYW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4aHJDYWxsYmFjayhoYW5kbGVyRGF0YSwgc2hvdWxkQ3JlYXRlU3Bhbiwgc3BhbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGN1cnJlbnRDbGllbnRPcHRpb25zID0gKF9hID0gZ2V0Q3VycmVudEh1YigpXG4gICAgICAgIC5nZXRDbGllbnQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldE9wdGlvbnMoKTtcbiAgICBpZiAoIShjdXJyZW50Q2xpZW50T3B0aW9ucyAmJiBoYXNUcmFjaW5nRW5hYmxlZChjdXJyZW50Q2xpZW50T3B0aW9ucykpIHx8XG4gICAgICAgICEoaGFuZGxlckRhdGEueGhyICYmIGhhbmRsZXJEYXRhLnhoci5fX3NlbnRyeV94aHJfXyAmJiBzaG91bGRDcmVhdGVTcGFuKGhhbmRsZXJEYXRhLnhoci5fX3NlbnRyeV94aHJfXy51cmwpKSB8fFxuICAgICAgICBoYW5kbGVyRGF0YS54aHIuX19zZW50cnlfb3duX3JlcXVlc3RfXykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB4aHIgPSBoYW5kbGVyRGF0YS54aHIuX19zZW50cnlfeGhyX187XG4gICAgLy8gY2hlY2sgZmlyc3QgaWYgdGhlIHJlcXVlc3QgaGFzIGZpbmlzaGVkIGFuZCBpcyB0cmFja2VkIGJ5IGFuIGV4aXN0aW5nIHNwYW4gd2hpY2ggc2hvdWxkIG5vdyBlbmRcbiAgICBpZiAoaGFuZGxlckRhdGEuZW5kVGltZXN0YW1wICYmIGhhbmRsZXJEYXRhLnhoci5fX3NlbnRyeV94aHJfc3Bhbl9pZF9fKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaGFuZGxlckRhdGEueGhyLl9fc2VudHJ5X3hocl9zcGFuX2lkX19dO1xuICAgICAgICBpZiAoc3Bhbikge1xuICAgICAgICAgICAgc3Bhbi5zZXRIdHRwU3RhdHVzKHhoci5zdGF0dXNfY29kZSk7XG4gICAgICAgICAgICBzcGFuLmZpbmlzaCgpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgZGVsZXRlIHNwYW5zW2hhbmRsZXJEYXRhLnhoci5fX3NlbnRyeV94aHJfc3Bhbl9pZF9fXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIG5vdCwgY3JlYXRlIGEgbmV3IHNwYW4gdG8gdHJhY2sgaXRcbiAgICB2YXIgYWN0aXZlVHJhbnNhY3Rpb24gPSBnZXRBY3RpdmVUcmFuc2FjdGlvbigpO1xuICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgc3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgICAgZGF0YTogX19hc3NpZ24oX19hc3NpZ24oe30sIHhoci5kYXRhKSwgeyB0eXBlOiAneGhyJywgbWV0aG9kOiB4aHIubWV0aG9kLCB1cmw6IHhoci51cmwgfSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogeGhyLm1ldGhvZCArIFwiIFwiICsgeGhyLnVybCxcbiAgICAgICAgICAgIG9wOiAnaHR0cCcsXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVyRGF0YS54aHIuX19zZW50cnlfeGhyX3NwYW5faWRfXyA9IHNwYW4uc3BhbklkO1xuICAgICAgICBzcGFuc1toYW5kbGVyRGF0YS54aHIuX19zZW50cnlfeGhyX3NwYW5faWRfX10gPSBzcGFuO1xuICAgICAgICBpZiAoaGFuZGxlckRhdGEueGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckRhdGEueGhyLnNldFJlcXVlc3RIZWFkZXIoJ3NlbnRyeS10cmFjZScsIHNwYW4udG9UcmFjZXBhcmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3I6IEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAnc2V0UmVxdWVzdEhlYWRlcicgb24gJ1hNTEh0dHBSZXF1ZXN0JzogVGhlIG9iamVjdCdzIHN0YXRlIG11c3QgYmUgT1BFTkVELlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64\n')}}]);